// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: raw.proto

package api

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type DisplayType int32

const (
	DisplayType_nil         DisplayType = 0
	DisplayType_Visible     DisplayType = 1
	DisplayType_Snapshot    DisplayType = 2
	DisplayType_Hidden      DisplayType = 3
	DisplayType_Placeholder DisplayType = 4
)

var DisplayType_name = map[int32]string{
	0: "DisplayType_nil",
	1: "Visible",
	2: "Snapshot",
	3: "Hidden",
	4: "Placeholder",
}
var DisplayType_value = map[string]int32{
	"DisplayType_nil": 0,
	"Visible":         1,
	"Snapshot":        2,
	"Hidden":          3,
	"Placeholder":     4,
}

func (x DisplayType) String() string {
	return proto.EnumName(DisplayType_name, int32(x))
}
func (DisplayType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{0}
}

type Alliance int32

const (
	Alliance_nil     Alliance = 0
	Alliance_Self    Alliance = 1
	Alliance_Ally    Alliance = 2
	Alliance_Neutral Alliance = 3
	Alliance_Enemy   Alliance = 4
)

var Alliance_name = map[int32]string{
	0: "Alliance_nil",
	1: "Self",
	2: "Ally",
	3: "Neutral",
	4: "Enemy",
}
var Alliance_value = map[string]int32{
	"Alliance_nil": 0,
	"Self":         1,
	"Ally":         2,
	"Neutral":      3,
	"Enemy":        4,
}

func (x Alliance) String() string {
	return proto.EnumName(Alliance_name, int32(x))
}
func (Alliance) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{1}
}

type CloakState int32

const (
	CloakState_CloakedUnknown  CloakState = 0
	CloakState_Cloaked         CloakState = 1
	CloakState_CloakedDetected CloakState = 2
	CloakState_NotCloaked      CloakState = 3
	CloakState_CloakedAllied   CloakState = 4
)

var CloakState_name = map[int32]string{
	0: "CloakedUnknown",
	1: "Cloaked",
	2: "CloakedDetected",
	3: "NotCloaked",
	4: "CloakedAllied",
}
var CloakState_value = map[string]int32{
	"CloakedUnknown":  0,
	"Cloaked":         1,
	"CloakedDetected": 2,
	"NotCloaked":      3,
	"CloakedAllied":   4,
}

func (x CloakState) String() string {
	return proto.EnumName(CloakState_name, int32(x))
}
func (CloakState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{2}
}

type StartRaw struct {
	MapSize        *Size2DI    `protobuf:"bytes,1,opt,name=map_size,json=mapSize" json:"map_size,omitempty"`
	PathingGrid    *ImageData  `protobuf:"bytes,2,opt,name=pathing_grid,json=pathingGrid" json:"pathing_grid,omitempty"`
	TerrainHeight  *ImageData  `protobuf:"bytes,3,opt,name=terrain_height,json=terrainHeight" json:"terrain_height,omitempty"`
	PlacementGrid  *ImageData  `protobuf:"bytes,4,opt,name=placement_grid,json=placementGrid" json:"placement_grid,omitempty"`
	PlayableArea   *RectangleI `protobuf:"bytes,5,opt,name=playable_area,json=playableArea" json:"playable_area,omitempty"`
	StartLocations []*Point2D  `protobuf:"bytes,6,rep,name=start_locations,json=startLocations" json:"start_locations,omitempty"`
}

func (m *StartRaw) Reset()         { *m = StartRaw{} }
func (m *StartRaw) String() string { return proto.CompactTextString(m) }
func (*StartRaw) ProtoMessage()    {}
func (*StartRaw) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{0}
}
func (m *StartRaw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartRaw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartRaw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StartRaw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartRaw.Merge(dst, src)
}
func (m *StartRaw) XXX_Size() int {
	return m.Size()
}
func (m *StartRaw) XXX_DiscardUnknown() {
	xxx_messageInfo_StartRaw.DiscardUnknown(m)
}

var xxx_messageInfo_StartRaw proto.InternalMessageInfo

func (m *StartRaw) GetMapSize() *Size2DI {
	if m != nil {
		return m.MapSize
	}
	return nil
}

func (m *StartRaw) GetPathingGrid() *ImageData {
	if m != nil {
		return m.PathingGrid
	}
	return nil
}

func (m *StartRaw) GetTerrainHeight() *ImageData {
	if m != nil {
		return m.TerrainHeight
	}
	return nil
}

func (m *StartRaw) GetPlacementGrid() *ImageData {
	if m != nil {
		return m.PlacementGrid
	}
	return nil
}

func (m *StartRaw) GetPlayableArea() *RectangleI {
	if m != nil {
		return m.PlayableArea
	}
	return nil
}

func (m *StartRaw) GetStartLocations() []*Point2D {
	if m != nil {
		return m.StartLocations
	}
	return nil
}

type ObservationRaw struct {
	Player   *PlayerRaw   `protobuf:"bytes,1,opt,name=player" json:"player,omitempty"`
	Units    []*Unit      `protobuf:"bytes,2,rep,name=units" json:"units,omitempty"`
	MapState *MapState    `protobuf:"bytes,3,opt,name=map_state,json=mapState" json:"map_state,omitempty"`
	Event    *Event       `protobuf:"bytes,4,opt,name=event" json:"event,omitempty"`
	Effects  []*Effect    `protobuf:"bytes,5,rep,name=effects" json:"effects,omitempty"`
	Radar    []*RadarRing `protobuf:"bytes,6,rep,name=radar" json:"radar,omitempty"`
}

func (m *ObservationRaw) Reset()         { *m = ObservationRaw{} }
func (m *ObservationRaw) String() string { return proto.CompactTextString(m) }
func (*ObservationRaw) ProtoMessage()    {}
func (*ObservationRaw) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{1}
}
func (m *ObservationRaw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObservationRaw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObservationRaw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ObservationRaw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObservationRaw.Merge(dst, src)
}
func (m *ObservationRaw) XXX_Size() int {
	return m.Size()
}
func (m *ObservationRaw) XXX_DiscardUnknown() {
	xxx_messageInfo_ObservationRaw.DiscardUnknown(m)
}

var xxx_messageInfo_ObservationRaw proto.InternalMessageInfo

func (m *ObservationRaw) GetPlayer() *PlayerRaw {
	if m != nil {
		return m.Player
	}
	return nil
}

func (m *ObservationRaw) GetUnits() []*Unit {
	if m != nil {
		return m.Units
	}
	return nil
}

func (m *ObservationRaw) GetMapState() *MapState {
	if m != nil {
		return m.MapState
	}
	return nil
}

func (m *ObservationRaw) GetEvent() *Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *ObservationRaw) GetEffects() []*Effect {
	if m != nil {
		return m.Effects
	}
	return nil
}

func (m *ObservationRaw) GetRadar() []*RadarRing {
	if m != nil {
		return m.Radar
	}
	return nil
}

type RadarRing struct {
	Pos    *Point  `protobuf:"bytes,1,opt,name=pos" json:"pos,omitempty"`
	Radius float32 `protobuf:"fixed32,2,opt,name=radius,proto3" json:"radius,omitempty"`
}

func (m *RadarRing) Reset()         { *m = RadarRing{} }
func (m *RadarRing) String() string { return proto.CompactTextString(m) }
func (*RadarRing) ProtoMessage()    {}
func (*RadarRing) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{2}
}
func (m *RadarRing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RadarRing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RadarRing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RadarRing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadarRing.Merge(dst, src)
}
func (m *RadarRing) XXX_Size() int {
	return m.Size()
}
func (m *RadarRing) XXX_DiscardUnknown() {
	xxx_messageInfo_RadarRing.DiscardUnknown(m)
}

var xxx_messageInfo_RadarRing proto.InternalMessageInfo

func (m *RadarRing) GetPos() *Point {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *RadarRing) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

type PowerSource struct {
	Pos    *Point  `protobuf:"bytes,1,opt,name=pos" json:"pos,omitempty"`
	Radius float32 `protobuf:"fixed32,2,opt,name=radius,proto3" json:"radius,omitempty"`
	Tag    UnitTag `protobuf:"varint,3,opt,name=tag,proto3,casttype=UnitTag" json:"tag,omitempty"`
}

func (m *PowerSource) Reset()         { *m = PowerSource{} }
func (m *PowerSource) String() string { return proto.CompactTextString(m) }
func (*PowerSource) ProtoMessage()    {}
func (*PowerSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{3}
}
func (m *PowerSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PowerSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PowerSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PowerSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PowerSource.Merge(dst, src)
}
func (m *PowerSource) XXX_Size() int {
	return m.Size()
}
func (m *PowerSource) XXX_DiscardUnknown() {
	xxx_messageInfo_PowerSource.DiscardUnknown(m)
}

var xxx_messageInfo_PowerSource proto.InternalMessageInfo

func (m *PowerSource) GetPos() *Point {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *PowerSource) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *PowerSource) GetTag() UnitTag {
	if m != nil {
		return m.Tag
	}
	return 0
}

type PlayerRaw struct {
	PowerSources []*PowerSource `protobuf:"bytes,1,rep,name=power_sources,json=powerSources" json:"power_sources,omitempty"`
	Camera       *Point         `protobuf:"bytes,2,opt,name=camera" json:"camera,omitempty"`
	UpgradeIds   []UpgradeID    `protobuf:"varint,3,rep,packed,name=upgrade_ids,json=upgradeIds,casttype=UpgradeID" json:"upgrade_ids,omitempty"`
}

func (m *PlayerRaw) Reset()         { *m = PlayerRaw{} }
func (m *PlayerRaw) String() string { return proto.CompactTextString(m) }
func (*PlayerRaw) ProtoMessage()    {}
func (*PlayerRaw) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{4}
}
func (m *PlayerRaw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerRaw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerRaw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PlayerRaw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerRaw.Merge(dst, src)
}
func (m *PlayerRaw) XXX_Size() int {
	return m.Size()
}
func (m *PlayerRaw) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerRaw.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerRaw proto.InternalMessageInfo

func (m *PlayerRaw) GetPowerSources() []*PowerSource {
	if m != nil {
		return m.PowerSources
	}
	return nil
}

func (m *PlayerRaw) GetCamera() *Point {
	if m != nil {
		return m.Camera
	}
	return nil
}

func (m *PlayerRaw) GetUpgradeIds() []UpgradeID {
	if m != nil {
		return m.UpgradeIds
	}
	return nil
}

type UnitOrder struct {
	AbilityId AbilityID `protobuf:"varint,1,opt,name=ability_id,json=abilityId,proto3,casttype=AbilityID" json:"ability_id,omitempty"`
	// Types that are valid to be assigned to Target:
	//	*UnitOrder_TargetWorldSpacePos
	//	*UnitOrder_TargetUnitTag
	Target   isUnitOrder_Target `protobuf_oneof:"target"`
	Progress float32            `protobuf:"fixed32,4,opt,name=progress,proto3" json:"progress,omitempty"`
}

func (m *UnitOrder) Reset()         { *m = UnitOrder{} }
func (m *UnitOrder) String() string { return proto.CompactTextString(m) }
func (*UnitOrder) ProtoMessage()    {}
func (*UnitOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{5}
}
func (m *UnitOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnitOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnitOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UnitOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnitOrder.Merge(dst, src)
}
func (m *UnitOrder) XXX_Size() int {
	return m.Size()
}
func (m *UnitOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_UnitOrder.DiscardUnknown(m)
}

var xxx_messageInfo_UnitOrder proto.InternalMessageInfo

type isUnitOrder_Target interface {
	isUnitOrder_Target()
	MarshalTo([]byte) (int, error)
	Size() int
}

type UnitOrder_TargetWorldSpacePos struct {
	TargetWorldSpacePos *Point `protobuf:"bytes,2,opt,name=target_world_space_pos,json=targetWorldSpacePos,oneof"`
}
type UnitOrder_TargetUnitTag struct {
	TargetUnitTag UnitTag `protobuf:"varint,3,opt,name=target_unit_tag,json=targetUnitTag,proto3,oneof,casttype=UnitTag"`
}

func (*UnitOrder_TargetWorldSpacePos) isUnitOrder_Target() {}
func (*UnitOrder_TargetUnitTag) isUnitOrder_Target()       {}

func (m *UnitOrder) GetTarget() isUnitOrder_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *UnitOrder) GetAbilityId() AbilityID {
	if m != nil {
		return m.AbilityId
	}
	return 0
}

func (m *UnitOrder) GetTargetWorldSpacePos() *Point {
	if x, ok := m.GetTarget().(*UnitOrder_TargetWorldSpacePos); ok {
		return x.TargetWorldSpacePos
	}
	return nil
}

func (m *UnitOrder) GetTargetUnitTag() UnitTag {
	if x, ok := m.GetTarget().(*UnitOrder_TargetUnitTag); ok {
		return x.TargetUnitTag
	}
	return 0
}

func (m *UnitOrder) GetProgress() float32 {
	if m != nil {
		return m.Progress
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*UnitOrder) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _UnitOrder_OneofMarshaler, _UnitOrder_OneofUnmarshaler, _UnitOrder_OneofSizer, []interface{}{
		(*UnitOrder_TargetWorldSpacePos)(nil),
		(*UnitOrder_TargetUnitTag)(nil),
	}
}

func _UnitOrder_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*UnitOrder)
	// target
	switch x := m.Target.(type) {
	case *UnitOrder_TargetWorldSpacePos:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TargetWorldSpacePos); err != nil {
			return err
		}
	case *UnitOrder_TargetUnitTag:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.TargetUnitTag))
	case nil:
	default:
		return fmt.Errorf("UnitOrder.Target has unexpected type %T", x)
	}
	return nil
}

func _UnitOrder_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*UnitOrder)
	switch tag {
	case 2: // target.target_world_space_pos
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Point)
		err := b.DecodeMessage(msg)
		m.Target = &UnitOrder_TargetWorldSpacePos{msg}
		return true, err
	case 3: // target.target_unit_tag
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Target = &UnitOrder_TargetUnitTag{UnitTag(x)}
		return true, err
	default:
		return false, nil
	}
}

func _UnitOrder_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*UnitOrder)
	// target
	switch x := m.Target.(type) {
	case *UnitOrder_TargetWorldSpacePos:
		s := proto.Size(x.TargetWorldSpacePos)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *UnitOrder_TargetUnitTag:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.TargetUnitTag))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PassengerUnit struct {
	Tag       UnitTag    `protobuf:"varint,1,opt,name=tag,proto3,casttype=UnitTag" json:"tag,omitempty"`
	Health    float32    `protobuf:"fixed32,2,opt,name=health,proto3" json:"health,omitempty"`
	HealthMax float32    `protobuf:"fixed32,3,opt,name=health_max,json=healthMax,proto3" json:"health_max,omitempty"`
	Shield    float32    `protobuf:"fixed32,4,opt,name=shield,proto3" json:"shield,omitempty"`
	ShieldMax float32    `protobuf:"fixed32,7,opt,name=shield_max,json=shieldMax,proto3" json:"shield_max,omitempty"`
	Energy    float32    `protobuf:"fixed32,5,opt,name=energy,proto3" json:"energy,omitempty"`
	EnergyMax float32    `protobuf:"fixed32,8,opt,name=energy_max,json=energyMax,proto3" json:"energy_max,omitempty"`
	UnitType  UnitTypeID `protobuf:"varint,6,opt,name=unit_type,json=unitType,proto3,casttype=UnitTypeID" json:"unit_type,omitempty"`
}

func (m *PassengerUnit) Reset()         { *m = PassengerUnit{} }
func (m *PassengerUnit) String() string { return proto.CompactTextString(m) }
func (*PassengerUnit) ProtoMessage()    {}
func (*PassengerUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{6}
}
func (m *PassengerUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PassengerUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PassengerUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PassengerUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PassengerUnit.Merge(dst, src)
}
func (m *PassengerUnit) XXX_Size() int {
	return m.Size()
}
func (m *PassengerUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_PassengerUnit.DiscardUnknown(m)
}

var xxx_messageInfo_PassengerUnit proto.InternalMessageInfo

func (m *PassengerUnit) GetTag() UnitTag {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *PassengerUnit) GetHealth() float32 {
	if m != nil {
		return m.Health
	}
	return 0
}

func (m *PassengerUnit) GetHealthMax() float32 {
	if m != nil {
		return m.HealthMax
	}
	return 0
}

func (m *PassengerUnit) GetShield() float32 {
	if m != nil {
		return m.Shield
	}
	return 0
}

func (m *PassengerUnit) GetShieldMax() float32 {
	if m != nil {
		return m.ShieldMax
	}
	return 0
}

func (m *PassengerUnit) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *PassengerUnit) GetEnergyMax() float32 {
	if m != nil {
		return m.EnergyMax
	}
	return 0
}

func (m *PassengerUnit) GetUnitType() UnitTypeID {
	if m != nil {
		return m.UnitType
	}
	return 0
}

type RallyTarget struct {
	Point *Point `protobuf:"bytes,1,opt,name=point" json:"point,omitempty"`
	Tag   uint64 `protobuf:"varint,2,opt,name=tag,proto3" json:"tag,omitempty"`
}

func (m *RallyTarget) Reset()         { *m = RallyTarget{} }
func (m *RallyTarget) String() string { return proto.CompactTextString(m) }
func (*RallyTarget) ProtoMessage()    {}
func (*RallyTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{7}
}
func (m *RallyTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RallyTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RallyTarget.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RallyTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RallyTarget.Merge(dst, src)
}
func (m *RallyTarget) XXX_Size() int {
	return m.Size()
}
func (m *RallyTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_RallyTarget.DiscardUnknown(m)
}

var xxx_messageInfo_RallyTarget proto.InternalMessageInfo

func (m *RallyTarget) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *RallyTarget) GetTag() uint64 {
	if m != nil {
		return m.Tag
	}
	return 0
}

type Unit struct {
	DisplayType        DisplayType      `protobuf:"varint,1,opt,name=display_type,json=displayType,proto3,enum=SC2APIProtocol.DisplayType" json:"display_type,omitempty"`
	Alliance           Alliance         `protobuf:"varint,2,opt,name=alliance,proto3,enum=SC2APIProtocol.Alliance" json:"alliance,omitempty"`
	Tag                UnitTag          `protobuf:"varint,3,opt,name=tag,proto3,casttype=UnitTag" json:"tag,omitempty"`
	UnitType           UnitTypeID       `protobuf:"varint,4,opt,name=unit_type,json=unitType,proto3,casttype=UnitTypeID" json:"unit_type,omitempty"`
	Owner              PlayerID         `protobuf:"varint,5,opt,name=owner,proto3,casttype=PlayerID" json:"owner,omitempty"`
	Pos                *Point           `protobuf:"bytes,6,opt,name=pos" json:"pos,omitempty"`
	Facing             float32          `protobuf:"fixed32,7,opt,name=facing,proto3" json:"facing,omitempty"`
	Radius             float32          `protobuf:"fixed32,8,opt,name=radius,proto3" json:"radius,omitempty"`
	BuildProgress      float32          `protobuf:"fixed32,9,opt,name=build_progress,json=buildProgress,proto3" json:"build_progress,omitempty"`
	Cloak              CloakState       `protobuf:"varint,10,opt,name=cloak,proto3,enum=SC2APIProtocol.CloakState" json:"cloak,omitempty"`
	BuffIds            []BuffID         `protobuf:"varint,27,rep,packed,name=buff_ids,json=buffIds,casttype=BuffID" json:"buff_ids,omitempty"`
	DetectRange        float32          `protobuf:"fixed32,31,opt,name=detect_range,json=detectRange,proto3" json:"detect_range,omitempty"`
	RadarRange         float32          `protobuf:"fixed32,32,opt,name=radar_range,json=radarRange,proto3" json:"radar_range,omitempty"`
	IsSelected         bool             `protobuf:"varint,11,opt,name=is_selected,json=isSelected,proto3" json:"is_selected,omitempty"`
	IsOnScreen         bool             `protobuf:"varint,12,opt,name=is_on_screen,json=isOnScreen,proto3" json:"is_on_screen,omitempty"`
	IsBlip             bool             `protobuf:"varint,13,opt,name=is_blip,json=isBlip,proto3" json:"is_blip,omitempty"`
	IsPowered          bool             `protobuf:"varint,35,opt,name=is_powered,json=isPowered,proto3" json:"is_powered,omitempty"`
	IsActive           bool             `protobuf:"varint,39,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	AttackUpgradeLevel int32            `protobuf:"varint,40,opt,name=attack_upgrade_level,json=attackUpgradeLevel,proto3" json:"attack_upgrade_level,omitempty"`
	ArmorUpgradeLevel  int32            `protobuf:"varint,41,opt,name=armor_upgrade_level,json=armorUpgradeLevel,proto3" json:"armor_upgrade_level,omitempty"`
	ShieldUpgradeLevel int32            `protobuf:"varint,42,opt,name=shield_upgrade_level,json=shieldUpgradeLevel,proto3" json:"shield_upgrade_level,omitempty"`
	Health             float32          `protobuf:"fixed32,14,opt,name=health,proto3" json:"health,omitempty"`
	HealthMax          float32          `protobuf:"fixed32,15,opt,name=health_max,json=healthMax,proto3" json:"health_max,omitempty"`
	Shield             float32          `protobuf:"fixed32,16,opt,name=shield,proto3" json:"shield,omitempty"`
	ShieldMax          float32          `protobuf:"fixed32,36,opt,name=shield_max,json=shieldMax,proto3" json:"shield_max,omitempty"`
	Energy             float32          `protobuf:"fixed32,17,opt,name=energy,proto3" json:"energy,omitempty"`
	EnergyMax          float32          `protobuf:"fixed32,37,opt,name=energy_max,json=energyMax,proto3" json:"energy_max,omitempty"`
	MineralContents    int32            `protobuf:"varint,18,opt,name=mineral_contents,json=mineralContents,proto3" json:"mineral_contents,omitempty"`
	VespeneContents    int32            `protobuf:"varint,19,opt,name=vespene_contents,json=vespeneContents,proto3" json:"vespene_contents,omitempty"`
	IsFlying           bool             `protobuf:"varint,20,opt,name=is_flying,json=isFlying,proto3" json:"is_flying,omitempty"`
	IsBurrowed         bool             `protobuf:"varint,21,opt,name=is_burrowed,json=isBurrowed,proto3" json:"is_burrowed,omitempty"`
	IsHallucination    bool             `protobuf:"varint,38,opt,name=is_hallucination,json=isHallucination,proto3" json:"is_hallucination,omitempty"`
	Orders             []*UnitOrder     `protobuf:"bytes,22,rep,name=orders" json:"orders,omitempty"`
	AddOnTag           UnitTag          `protobuf:"varint,23,opt,name=add_on_tag,json=addOnTag,proto3,casttype=UnitTag" json:"add_on_tag,omitempty"`
	Passengers         []*PassengerUnit `protobuf:"bytes,24,rep,name=passengers" json:"passengers,omitempty"`
	CargoSpaceTaken    int32            `protobuf:"varint,25,opt,name=cargo_space_taken,json=cargoSpaceTaken,proto3" json:"cargo_space_taken,omitempty"`
	CargoSpaceMax      int32            `protobuf:"varint,26,opt,name=cargo_space_max,json=cargoSpaceMax,proto3" json:"cargo_space_max,omitempty"`
	AssignedHarvesters int32            `protobuf:"varint,28,opt,name=assigned_harvesters,json=assignedHarvesters,proto3" json:"assigned_harvesters,omitempty"`
	IdealHarvesters    int32            `protobuf:"varint,29,opt,name=ideal_harvesters,json=idealHarvesters,proto3" json:"ideal_harvesters,omitempty"`
	WeaponCooldown     float32          `protobuf:"fixed32,30,opt,name=weapon_cooldown,json=weaponCooldown,proto3" json:"weapon_cooldown,omitempty"`
	EngagedTargetTag   UnitTag          `protobuf:"varint,34,opt,name=engaged_target_tag,json=engagedTargetTag,proto3,casttype=UnitTag" json:"engaged_target_tag,omitempty"`
	BuffDurationRemain int32            `protobuf:"varint,43,opt,name=buff_duration_remain,json=buffDurationRemain,proto3" json:"buff_duration_remain,omitempty"`
	BuffDurationMax    int32            `protobuf:"varint,44,opt,name=buff_duration_max,json=buffDurationMax,proto3" json:"buff_duration_max,omitempty"`
	RallyTargets       []*RallyTarget   `protobuf:"bytes,45,rep,name=rally_targets,json=rallyTargets" json:"rally_targets,omitempty"`
}

func (m *Unit) Reset()         { *m = Unit{} }
func (m *Unit) String() string { return proto.CompactTextString(m) }
func (*Unit) ProtoMessage()    {}
func (*Unit) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{8}
}
func (m *Unit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Unit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Unit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Unit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Unit.Merge(dst, src)
}
func (m *Unit) XXX_Size() int {
	return m.Size()
}
func (m *Unit) XXX_DiscardUnknown() {
	xxx_messageInfo_Unit.DiscardUnknown(m)
}

var xxx_messageInfo_Unit proto.InternalMessageInfo

func (m *Unit) GetDisplayType() DisplayType {
	if m != nil {
		return m.DisplayType
	}
	return DisplayType_nil
}

func (m *Unit) GetAlliance() Alliance {
	if m != nil {
		return m.Alliance
	}
	return Alliance_nil
}

func (m *Unit) GetTag() UnitTag {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *Unit) GetUnitType() UnitTypeID {
	if m != nil {
		return m.UnitType
	}
	return 0
}

func (m *Unit) GetOwner() PlayerID {
	if m != nil {
		return m.Owner
	}
	return 0
}

func (m *Unit) GetPos() *Point {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Unit) GetFacing() float32 {
	if m != nil {
		return m.Facing
	}
	return 0
}

func (m *Unit) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *Unit) GetBuildProgress() float32 {
	if m != nil {
		return m.BuildProgress
	}
	return 0
}

func (m *Unit) GetCloak() CloakState {
	if m != nil {
		return m.Cloak
	}
	return CloakState_CloakedUnknown
}

func (m *Unit) GetBuffIds() []BuffID {
	if m != nil {
		return m.BuffIds
	}
	return nil
}

func (m *Unit) GetDetectRange() float32 {
	if m != nil {
		return m.DetectRange
	}
	return 0
}

func (m *Unit) GetRadarRange() float32 {
	if m != nil {
		return m.RadarRange
	}
	return 0
}

func (m *Unit) GetIsSelected() bool {
	if m != nil {
		return m.IsSelected
	}
	return false
}

func (m *Unit) GetIsOnScreen() bool {
	if m != nil {
		return m.IsOnScreen
	}
	return false
}

func (m *Unit) GetIsBlip() bool {
	if m != nil {
		return m.IsBlip
	}
	return false
}

func (m *Unit) GetIsPowered() bool {
	if m != nil {
		return m.IsPowered
	}
	return false
}

func (m *Unit) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *Unit) GetAttackUpgradeLevel() int32 {
	if m != nil {
		return m.AttackUpgradeLevel
	}
	return 0
}

func (m *Unit) GetArmorUpgradeLevel() int32 {
	if m != nil {
		return m.ArmorUpgradeLevel
	}
	return 0
}

func (m *Unit) GetShieldUpgradeLevel() int32 {
	if m != nil {
		return m.ShieldUpgradeLevel
	}
	return 0
}

func (m *Unit) GetHealth() float32 {
	if m != nil {
		return m.Health
	}
	return 0
}

func (m *Unit) GetHealthMax() float32 {
	if m != nil {
		return m.HealthMax
	}
	return 0
}

func (m *Unit) GetShield() float32 {
	if m != nil {
		return m.Shield
	}
	return 0
}

func (m *Unit) GetShieldMax() float32 {
	if m != nil {
		return m.ShieldMax
	}
	return 0
}

func (m *Unit) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *Unit) GetEnergyMax() float32 {
	if m != nil {
		return m.EnergyMax
	}
	return 0
}

func (m *Unit) GetMineralContents() int32 {
	if m != nil {
		return m.MineralContents
	}
	return 0
}

func (m *Unit) GetVespeneContents() int32 {
	if m != nil {
		return m.VespeneContents
	}
	return 0
}

func (m *Unit) GetIsFlying() bool {
	if m != nil {
		return m.IsFlying
	}
	return false
}

func (m *Unit) GetIsBurrowed() bool {
	if m != nil {
		return m.IsBurrowed
	}
	return false
}

func (m *Unit) GetIsHallucination() bool {
	if m != nil {
		return m.IsHallucination
	}
	return false
}

func (m *Unit) GetOrders() []*UnitOrder {
	if m != nil {
		return m.Orders
	}
	return nil
}

func (m *Unit) GetAddOnTag() UnitTag {
	if m != nil {
		return m.AddOnTag
	}
	return 0
}

func (m *Unit) GetPassengers() []*PassengerUnit {
	if m != nil {
		return m.Passengers
	}
	return nil
}

func (m *Unit) GetCargoSpaceTaken() int32 {
	if m != nil {
		return m.CargoSpaceTaken
	}
	return 0
}

func (m *Unit) GetCargoSpaceMax() int32 {
	if m != nil {
		return m.CargoSpaceMax
	}
	return 0
}

func (m *Unit) GetAssignedHarvesters() int32 {
	if m != nil {
		return m.AssignedHarvesters
	}
	return 0
}

func (m *Unit) GetIdealHarvesters() int32 {
	if m != nil {
		return m.IdealHarvesters
	}
	return 0
}

func (m *Unit) GetWeaponCooldown() float32 {
	if m != nil {
		return m.WeaponCooldown
	}
	return 0
}

func (m *Unit) GetEngagedTargetTag() UnitTag {
	if m != nil {
		return m.EngagedTargetTag
	}
	return 0
}

func (m *Unit) GetBuffDurationRemain() int32 {
	if m != nil {
		return m.BuffDurationRemain
	}
	return 0
}

func (m *Unit) GetBuffDurationMax() int32 {
	if m != nil {
		return m.BuffDurationMax
	}
	return 0
}

func (m *Unit) GetRallyTargets() []*RallyTarget {
	if m != nil {
		return m.RallyTargets
	}
	return nil
}

type MapState struct {
	Visibility *ImageData `protobuf:"bytes,1,opt,name=visibility" json:"visibility,omitempty"`
	Creep      *ImageData `protobuf:"bytes,2,opt,name=creep" json:"creep,omitempty"`
}

func (m *MapState) Reset()         { *m = MapState{} }
func (m *MapState) String() string { return proto.CompactTextString(m) }
func (*MapState) ProtoMessage()    {}
func (*MapState) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{9}
}
func (m *MapState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MapState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MapState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MapState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapState.Merge(dst, src)
}
func (m *MapState) XXX_Size() int {
	return m.Size()
}
func (m *MapState) XXX_DiscardUnknown() {
	xxx_messageInfo_MapState.DiscardUnknown(m)
}

var xxx_messageInfo_MapState proto.InternalMessageInfo

func (m *MapState) GetVisibility() *ImageData {
	if m != nil {
		return m.Visibility
	}
	return nil
}

func (m *MapState) GetCreep() *ImageData {
	if m != nil {
		return m.Creep
	}
	return nil
}

type Event struct {
	DeadUnits []UnitTag `protobuf:"varint,1,rep,packed,name=dead_units,json=deadUnits,casttype=UnitTag" json:"dead_units,omitempty"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{10}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(dst, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetDeadUnits() []UnitTag {
	if m != nil {
		return m.DeadUnits
	}
	return nil
}

type Effect struct {
	EffectId EffectID   `protobuf:"varint,1,opt,name=effect_id,json=effectId,proto3,casttype=EffectID" json:"effect_id,omitempty"`
	Pos      []*Point2D `protobuf:"bytes,2,rep,name=pos" json:"pos,omitempty"`
	Alliance Alliance   `protobuf:"varint,3,opt,name=alliance,proto3,enum=SC2APIProtocol.Alliance" json:"alliance,omitempty"`
	Owner    int32      `protobuf:"varint,4,opt,name=owner,proto3" json:"owner,omitempty"`
	Radius   float32    `protobuf:"fixed32,5,opt,name=radius,proto3" json:"radius,omitempty"`
}

func (m *Effect) Reset()         { *m = Effect{} }
func (m *Effect) String() string { return proto.CompactTextString(m) }
func (*Effect) ProtoMessage()    {}
func (*Effect) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{11}
}
func (m *Effect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Effect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Effect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Effect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Effect.Merge(dst, src)
}
func (m *Effect) XXX_Size() int {
	return m.Size()
}
func (m *Effect) XXX_DiscardUnknown() {
	xxx_messageInfo_Effect.DiscardUnknown(m)
}

var xxx_messageInfo_Effect proto.InternalMessageInfo

func (m *Effect) GetEffectId() EffectID {
	if m != nil {
		return m.EffectId
	}
	return 0
}

func (m *Effect) GetPos() []*Point2D {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Effect) GetAlliance() Alliance {
	if m != nil {
		return m.Alliance
	}
	return Alliance_nil
}

func (m *Effect) GetOwner() int32 {
	if m != nil {
		return m.Owner
	}
	return 0
}

func (m *Effect) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

type ActionRaw struct {
	// Types that are valid to be assigned to Action:
	//	*ActionRaw_UnitCommand
	//	*ActionRaw_CameraMove
	//	*ActionRaw_ToggleAutocast
	Action isActionRaw_Action `protobuf_oneof:"action"`
}

func (m *ActionRaw) Reset()         { *m = ActionRaw{} }
func (m *ActionRaw) String() string { return proto.CompactTextString(m) }
func (*ActionRaw) ProtoMessage()    {}
func (*ActionRaw) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{12}
}
func (m *ActionRaw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionRaw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionRaw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionRaw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionRaw.Merge(dst, src)
}
func (m *ActionRaw) XXX_Size() int {
	return m.Size()
}
func (m *ActionRaw) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionRaw.DiscardUnknown(m)
}

var xxx_messageInfo_ActionRaw proto.InternalMessageInfo

type isActionRaw_Action interface {
	isActionRaw_Action()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ActionRaw_UnitCommand struct {
	UnitCommand *ActionRawUnitCommand `protobuf:"bytes,1,opt,name=unit_command,json=unitCommand,oneof"`
}
type ActionRaw_CameraMove struct {
	CameraMove *ActionRawCameraMove `protobuf:"bytes,2,opt,name=camera_move,json=cameraMove,oneof"`
}
type ActionRaw_ToggleAutocast struct {
	ToggleAutocast *ActionRawToggleAutocast `protobuf:"bytes,3,opt,name=toggle_autocast,json=toggleAutocast,oneof"`
}

func (*ActionRaw_UnitCommand) isActionRaw_Action()    {}
func (*ActionRaw_CameraMove) isActionRaw_Action()     {}
func (*ActionRaw_ToggleAutocast) isActionRaw_Action() {}

func (m *ActionRaw) GetAction() isActionRaw_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *ActionRaw) GetUnitCommand() *ActionRawUnitCommand {
	if x, ok := m.GetAction().(*ActionRaw_UnitCommand); ok {
		return x.UnitCommand
	}
	return nil
}

func (m *ActionRaw) GetCameraMove() *ActionRawCameraMove {
	if x, ok := m.GetAction().(*ActionRaw_CameraMove); ok {
		return x.CameraMove
	}
	return nil
}

func (m *ActionRaw) GetToggleAutocast() *ActionRawToggleAutocast {
	if x, ok := m.GetAction().(*ActionRaw_ToggleAutocast); ok {
		return x.ToggleAutocast
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ActionRaw) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ActionRaw_OneofMarshaler, _ActionRaw_OneofUnmarshaler, _ActionRaw_OneofSizer, []interface{}{
		(*ActionRaw_UnitCommand)(nil),
		(*ActionRaw_CameraMove)(nil),
		(*ActionRaw_ToggleAutocast)(nil),
	}
}

func _ActionRaw_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ActionRaw)
	// action
	switch x := m.Action.(type) {
	case *ActionRaw_UnitCommand:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UnitCommand); err != nil {
			return err
		}
	case *ActionRaw_CameraMove:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CameraMove); err != nil {
			return err
		}
	case *ActionRaw_ToggleAutocast:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ToggleAutocast); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ActionRaw.Action has unexpected type %T", x)
	}
	return nil
}

func _ActionRaw_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ActionRaw)
	switch tag {
	case 1: // action.unit_command
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ActionRawUnitCommand)
		err := b.DecodeMessage(msg)
		m.Action = &ActionRaw_UnitCommand{msg}
		return true, err
	case 2: // action.camera_move
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ActionRawCameraMove)
		err := b.DecodeMessage(msg)
		m.Action = &ActionRaw_CameraMove{msg}
		return true, err
	case 3: // action.toggle_autocast
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ActionRawToggleAutocast)
		err := b.DecodeMessage(msg)
		m.Action = &ActionRaw_ToggleAutocast{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ActionRaw_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ActionRaw)
	// action
	switch x := m.Action.(type) {
	case *ActionRaw_UnitCommand:
		s := proto.Size(x.UnitCommand)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ActionRaw_CameraMove:
		s := proto.Size(x.CameraMove)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ActionRaw_ToggleAutocast:
		s := proto.Size(x.ToggleAutocast)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ActionRawUnitCommand struct {
	AbilityId AbilityID `protobuf:"varint,1,opt,name=ability_id,json=abilityId,proto3,casttype=AbilityID" json:"ability_id,omitempty"`
	// Types that are valid to be assigned to Target:
	//	*ActionRawUnitCommand_TargetWorldSpacePos
	//	*ActionRawUnitCommand_TargetUnitTag
	Target       isActionRawUnitCommand_Target `protobuf_oneof:"target"`
	UnitTags     []UnitTag                     `protobuf:"varint,4,rep,packed,name=unit_tags,json=unitTags,casttype=UnitTag" json:"unit_tags,omitempty"`
	QueueCommand bool                          `protobuf:"varint,5,opt,name=queue_command,json=queueCommand,proto3" json:"queue_command,omitempty"`
}

func (m *ActionRawUnitCommand) Reset()         { *m = ActionRawUnitCommand{} }
func (m *ActionRawUnitCommand) String() string { return proto.CompactTextString(m) }
func (*ActionRawUnitCommand) ProtoMessage()    {}
func (*ActionRawUnitCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{13}
}
func (m *ActionRawUnitCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionRawUnitCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionRawUnitCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionRawUnitCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionRawUnitCommand.Merge(dst, src)
}
func (m *ActionRawUnitCommand) XXX_Size() int {
	return m.Size()
}
func (m *ActionRawUnitCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionRawUnitCommand.DiscardUnknown(m)
}

var xxx_messageInfo_ActionRawUnitCommand proto.InternalMessageInfo

type isActionRawUnitCommand_Target interface {
	isActionRawUnitCommand_Target()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ActionRawUnitCommand_TargetWorldSpacePos struct {
	TargetWorldSpacePos *Point2D `protobuf:"bytes,2,opt,name=target_world_space_pos,json=targetWorldSpacePos,oneof"`
}
type ActionRawUnitCommand_TargetUnitTag struct {
	TargetUnitTag UnitTag `protobuf:"varint,3,opt,name=target_unit_tag,json=targetUnitTag,proto3,oneof,casttype=UnitTag"`
}

func (*ActionRawUnitCommand_TargetWorldSpacePos) isActionRawUnitCommand_Target() {}
func (*ActionRawUnitCommand_TargetUnitTag) isActionRawUnitCommand_Target()       {}

func (m *ActionRawUnitCommand) GetTarget() isActionRawUnitCommand_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *ActionRawUnitCommand) GetAbilityId() AbilityID {
	if m != nil {
		return m.AbilityId
	}
	return 0
}

func (m *ActionRawUnitCommand) GetTargetWorldSpacePos() *Point2D {
	if x, ok := m.GetTarget().(*ActionRawUnitCommand_TargetWorldSpacePos); ok {
		return x.TargetWorldSpacePos
	}
	return nil
}

func (m *ActionRawUnitCommand) GetTargetUnitTag() UnitTag {
	if x, ok := m.GetTarget().(*ActionRawUnitCommand_TargetUnitTag); ok {
		return x.TargetUnitTag
	}
	return 0
}

func (m *ActionRawUnitCommand) GetUnitTags() []UnitTag {
	if m != nil {
		return m.UnitTags
	}
	return nil
}

func (m *ActionRawUnitCommand) GetQueueCommand() bool {
	if m != nil {
		return m.QueueCommand
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ActionRawUnitCommand) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ActionRawUnitCommand_OneofMarshaler, _ActionRawUnitCommand_OneofUnmarshaler, _ActionRawUnitCommand_OneofSizer, []interface{}{
		(*ActionRawUnitCommand_TargetWorldSpacePos)(nil),
		(*ActionRawUnitCommand_TargetUnitTag)(nil),
	}
}

func _ActionRawUnitCommand_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ActionRawUnitCommand)
	// target
	switch x := m.Target.(type) {
	case *ActionRawUnitCommand_TargetWorldSpacePos:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TargetWorldSpacePos); err != nil {
			return err
		}
	case *ActionRawUnitCommand_TargetUnitTag:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.TargetUnitTag))
	case nil:
	default:
		return fmt.Errorf("ActionRawUnitCommand.Target has unexpected type %T", x)
	}
	return nil
}

func _ActionRawUnitCommand_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ActionRawUnitCommand)
	switch tag {
	case 2: // target.target_world_space_pos
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Point2D)
		err := b.DecodeMessage(msg)
		m.Target = &ActionRawUnitCommand_TargetWorldSpacePos{msg}
		return true, err
	case 3: // target.target_unit_tag
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Target = &ActionRawUnitCommand_TargetUnitTag{UnitTag(x)}
		return true, err
	default:
		return false, nil
	}
}

func _ActionRawUnitCommand_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ActionRawUnitCommand)
	// target
	switch x := m.Target.(type) {
	case *ActionRawUnitCommand_TargetWorldSpacePos:
		s := proto.Size(x.TargetWorldSpacePos)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ActionRawUnitCommand_TargetUnitTag:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.TargetUnitTag))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ActionRawCameraMove struct {
	CenterWorldSpace *Point `protobuf:"bytes,1,opt,name=center_world_space,json=centerWorldSpace" json:"center_world_space,omitempty"`
}

func (m *ActionRawCameraMove) Reset()         { *m = ActionRawCameraMove{} }
func (m *ActionRawCameraMove) String() string { return proto.CompactTextString(m) }
func (*ActionRawCameraMove) ProtoMessage()    {}
func (*ActionRawCameraMove) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{14}
}
func (m *ActionRawCameraMove) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionRawCameraMove) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionRawCameraMove.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionRawCameraMove) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionRawCameraMove.Merge(dst, src)
}
func (m *ActionRawCameraMove) XXX_Size() int {
	return m.Size()
}
func (m *ActionRawCameraMove) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionRawCameraMove.DiscardUnknown(m)
}

var xxx_messageInfo_ActionRawCameraMove proto.InternalMessageInfo

func (m *ActionRawCameraMove) GetCenterWorldSpace() *Point {
	if m != nil {
		return m.CenterWorldSpace
	}
	return nil
}

type ActionRawToggleAutocast struct {
	AbilityId AbilityID `protobuf:"varint,1,opt,name=ability_id,json=abilityId,proto3,casttype=AbilityID" json:"ability_id,omitempty"`
	UnitTags  []UnitTag `protobuf:"varint,2,rep,packed,name=unit_tags,json=unitTags,casttype=UnitTag" json:"unit_tags,omitempty"`
}

func (m *ActionRawToggleAutocast) Reset()         { *m = ActionRawToggleAutocast{} }
func (m *ActionRawToggleAutocast) String() string { return proto.CompactTextString(m) }
func (*ActionRawToggleAutocast) ProtoMessage()    {}
func (*ActionRawToggleAutocast) Descriptor() ([]byte, []int) {
	return fileDescriptor_raw_2125900401486f3f, []int{15}
}
func (m *ActionRawToggleAutocast) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionRawToggleAutocast) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionRawToggleAutocast.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionRawToggleAutocast) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionRawToggleAutocast.Merge(dst, src)
}
func (m *ActionRawToggleAutocast) XXX_Size() int {
	return m.Size()
}
func (m *ActionRawToggleAutocast) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionRawToggleAutocast.DiscardUnknown(m)
}

var xxx_messageInfo_ActionRawToggleAutocast proto.InternalMessageInfo

func (m *ActionRawToggleAutocast) GetAbilityId() AbilityID {
	if m != nil {
		return m.AbilityId
	}
	return 0
}

func (m *ActionRawToggleAutocast) GetUnitTags() []UnitTag {
	if m != nil {
		return m.UnitTags
	}
	return nil
}

func init() {
	proto.RegisterType((*StartRaw)(nil), "SC2APIProtocol.StartRaw")
	proto.RegisterType((*ObservationRaw)(nil), "SC2APIProtocol.ObservationRaw")
	proto.RegisterType((*RadarRing)(nil), "SC2APIProtocol.RadarRing")
	proto.RegisterType((*PowerSource)(nil), "SC2APIProtocol.PowerSource")
	proto.RegisterType((*PlayerRaw)(nil), "SC2APIProtocol.PlayerRaw")
	proto.RegisterType((*UnitOrder)(nil), "SC2APIProtocol.UnitOrder")
	proto.RegisterType((*PassengerUnit)(nil), "SC2APIProtocol.PassengerUnit")
	proto.RegisterType((*RallyTarget)(nil), "SC2APIProtocol.RallyTarget")
	proto.RegisterType((*Unit)(nil), "SC2APIProtocol.Unit")
	proto.RegisterType((*MapState)(nil), "SC2APIProtocol.MapState")
	proto.RegisterType((*Event)(nil), "SC2APIProtocol.Event")
	proto.RegisterType((*Effect)(nil), "SC2APIProtocol.Effect")
	proto.RegisterType((*ActionRaw)(nil), "SC2APIProtocol.ActionRaw")
	proto.RegisterType((*ActionRawUnitCommand)(nil), "SC2APIProtocol.ActionRawUnitCommand")
	proto.RegisterType((*ActionRawCameraMove)(nil), "SC2APIProtocol.ActionRawCameraMove")
	proto.RegisterType((*ActionRawToggleAutocast)(nil), "SC2APIProtocol.ActionRawToggleAutocast")
	proto.RegisterEnum("SC2APIProtocol.DisplayType", DisplayType_name, DisplayType_value)
	proto.RegisterEnum("SC2APIProtocol.Alliance", Alliance_name, Alliance_value)
	proto.RegisterEnum("SC2APIProtocol.CloakState", CloakState_name, CloakState_value)
}
func (m *StartRaw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartRaw) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MapSize != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.MapSize.Size()))
		n1, err := m.MapSize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.PathingGrid != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.PathingGrid.Size()))
		n2, err := m.PathingGrid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.TerrainHeight != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.TerrainHeight.Size()))
		n3, err := m.TerrainHeight.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.PlacementGrid != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.PlacementGrid.Size()))
		n4, err := m.PlacementGrid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.PlayableArea != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.PlayableArea.Size()))
		n5, err := m.PlayableArea.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.StartLocations) > 0 {
		for _, msg := range m.StartLocations {
			dAtA[i] = 0x32
			i++
			i = encodeVarintRaw(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ObservationRaw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObservationRaw) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Player != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Player.Size()))
		n6, err := m.Player.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Units) > 0 {
		for _, msg := range m.Units {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRaw(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MapState != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.MapState.Size()))
		n7, err := m.MapState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Event != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Event.Size()))
		n8, err := m.Event.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Effects) > 0 {
		for _, msg := range m.Effects {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRaw(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Radar) > 0 {
		for _, msg := range m.Radar {
			dAtA[i] = 0x32
			i++
			i = encodeVarintRaw(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RadarRing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RadarRing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Pos.Size()))
		n9, err := m.Pos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Radius != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Radius))))
		i += 4
	}
	return i, nil
}

func (m *PowerSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PowerSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Pos.Size()))
		n10, err := m.Pos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Radius != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Radius))))
		i += 4
	}
	if m.Tag != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Tag))
	}
	return i, nil
}

func (m *PlayerRaw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerRaw) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PowerSources) > 0 {
		for _, msg := range m.PowerSources {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRaw(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Camera != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Camera.Size()))
		n11, err := m.Camera.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.UpgradeIds) > 0 {
		dAtA13 := make([]byte, len(m.UpgradeIds)*10)
		var j12 int
		for _, num := range m.UpgradeIds {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRaw(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	return i, nil
}

func (m *UnitOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnitOrder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AbilityId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.AbilityId))
	}
	if m.Target != nil {
		nn14, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	if m.Progress != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Progress))))
		i += 4
	}
	return i, nil
}

func (m *UnitOrder_TargetWorldSpacePos) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TargetWorldSpacePos != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.TargetWorldSpacePos.Size()))
		n15, err := m.TargetWorldSpacePos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *UnitOrder_TargetUnitTag) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaw(dAtA, i, uint64(m.TargetUnitTag))
	return i, nil
}
func (m *PassengerUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassengerUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Tag))
	}
	if m.Health != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Health))))
		i += 4
	}
	if m.HealthMax != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HealthMax))))
		i += 4
	}
	if m.Shield != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Shield))))
		i += 4
	}
	if m.Energy != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if m.UnitType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.UnitType))
	}
	if m.ShieldMax != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ShieldMax))))
		i += 4
	}
	if m.EnergyMax != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EnergyMax))))
		i += 4
	}
	return i, nil
}

func (m *RallyTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RallyTarget) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Point != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Point.Size()))
		n16, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Tag != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Tag))
	}
	return i, nil
}

func (m *Unit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Unit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DisplayType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.DisplayType))
	}
	if m.Alliance != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Alliance))
	}
	if m.Tag != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Tag))
	}
	if m.UnitType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.UnitType))
	}
	if m.Owner != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Owner))
	}
	if m.Pos != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Pos.Size()))
		n17, err := m.Pos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Facing != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Facing))))
		i += 4
	}
	if m.Radius != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Radius))))
		i += 4
	}
	if m.BuildProgress != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BuildProgress))))
		i += 4
	}
	if m.Cloak != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Cloak))
	}
	if m.IsSelected {
		dAtA[i] = 0x58
		i++
		if m.IsSelected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsOnScreen {
		dAtA[i] = 0x60
		i++
		if m.IsOnScreen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsBlip {
		dAtA[i] = 0x68
		i++
		if m.IsBlip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Health != 0 {
		dAtA[i] = 0x75
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Health))))
		i += 4
	}
	if m.HealthMax != 0 {
		dAtA[i] = 0x7d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HealthMax))))
		i += 4
	}
	if m.Shield != 0 {
		dAtA[i] = 0x85
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Shield))))
		i += 4
	}
	if m.Energy != 0 {
		dAtA[i] = 0x8d
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if m.MineralContents != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.MineralContents))
	}
	if m.VespeneContents != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.VespeneContents))
	}
	if m.IsFlying {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.IsFlying {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsBurrowed {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.IsBurrowed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Orders) > 0 {
		for _, msg := range m.Orders {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintRaw(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AddOnTag != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.AddOnTag))
	}
	if len(m.Passengers) > 0 {
		for _, msg := range m.Passengers {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintRaw(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CargoSpaceTaken != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.CargoSpaceTaken))
	}
	if m.CargoSpaceMax != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.CargoSpaceMax))
	}
	if len(m.BuffIds) > 0 {
		dAtA19 := make([]byte, len(m.BuffIds)*10)
		var j18 int
		for _, num := range m.BuffIds {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRaw(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	if m.AssignedHarvesters != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.AssignedHarvesters))
	}
	if m.IdealHarvesters != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.IdealHarvesters))
	}
	if m.WeaponCooldown != 0 {
		dAtA[i] = 0xf5
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WeaponCooldown))))
		i += 4
	}
	if m.DetectRange != 0 {
		dAtA[i] = 0xfd
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DetectRange))))
		i += 4
	}
	if m.RadarRange != 0 {
		dAtA[i] = 0x85
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RadarRange))))
		i += 4
	}
	if m.EngagedTargetTag != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.EngagedTargetTag))
	}
	if m.IsPowered {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		if m.IsPowered {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ShieldMax != 0 {
		dAtA[i] = 0xa5
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ShieldMax))))
		i += 4
	}
	if m.EnergyMax != 0 {
		dAtA[i] = 0xad
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EnergyMax))))
		i += 4
	}
	if m.IsHallucination {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		if m.IsHallucination {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsActive {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AttackUpgradeLevel != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.AttackUpgradeLevel))
	}
	if m.ArmorUpgradeLevel != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.ArmorUpgradeLevel))
	}
	if m.ShieldUpgradeLevel != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.ShieldUpgradeLevel))
	}
	if m.BuffDurationRemain != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.BuffDurationRemain))
	}
	if m.BuffDurationMax != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.BuffDurationMax))
	}
	if len(m.RallyTargets) > 0 {
		for _, msg := range m.RallyTargets {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintRaw(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MapState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Visibility != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Visibility.Size()))
		n20, err := m.Visibility.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Creep != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Creep.Size()))
		n21, err := m.Creep.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DeadUnits) > 0 {
		dAtA23 := make([]byte, len(m.DeadUnits)*10)
		var j22 int
		for _, num := range m.DeadUnits {
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintRaw(dAtA, i, uint64(j22))
		i += copy(dAtA[i:], dAtA23[:j22])
	}
	return i, nil
}

func (m *Effect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Effect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EffectId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.EffectId))
	}
	if len(m.Pos) > 0 {
		for _, msg := range m.Pos {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRaw(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Alliance != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Alliance))
	}
	if m.Owner != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.Owner))
	}
	if m.Radius != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Radius))))
		i += 4
	}
	return i, nil
}

func (m *ActionRaw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionRaw) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		nn24, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn24
	}
	return i, nil
}

func (m *ActionRaw_UnitCommand) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UnitCommand != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.UnitCommand.Size()))
		n25, err := m.UnitCommand.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *ActionRaw_CameraMove) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CameraMove != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.CameraMove.Size()))
		n26, err := m.CameraMove.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *ActionRaw_ToggleAutocast) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ToggleAutocast != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.ToggleAutocast.Size()))
		n27, err := m.ToggleAutocast.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *ActionRawUnitCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionRawUnitCommand) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AbilityId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.AbilityId))
	}
	if m.Target != nil {
		nn28, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn28
	}
	if len(m.UnitTags) > 0 {
		dAtA30 := make([]byte, len(m.UnitTags)*10)
		var j29 int
		for _, num := range m.UnitTags {
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintRaw(dAtA, i, uint64(j29))
		i += copy(dAtA[i:], dAtA30[:j29])
	}
	if m.QueueCommand {
		dAtA[i] = 0x28
		i++
		if m.QueueCommand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ActionRawUnitCommand_TargetWorldSpacePos) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TargetWorldSpacePos != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.TargetWorldSpacePos.Size()))
		n31, err := m.TargetWorldSpacePos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *ActionRawUnitCommand_TargetUnitTag) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaw(dAtA, i, uint64(m.TargetUnitTag))
	return i, nil
}
func (m *ActionRawCameraMove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionRawCameraMove) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CenterWorldSpace != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.CenterWorldSpace.Size()))
		n32, err := m.CenterWorldSpace.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *ActionRawToggleAutocast) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionRawToggleAutocast) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AbilityId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRaw(dAtA, i, uint64(m.AbilityId))
	}
	if len(m.UnitTags) > 0 {
		dAtA34 := make([]byte, len(m.UnitTags)*10)
		var j33 int
		for _, num := range m.UnitTags {
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintRaw(dAtA, i, uint64(j33))
		i += copy(dAtA[i:], dAtA34[:j33])
	}
	return i, nil
}

func encodeVarintRaw(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *StartRaw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MapSize != nil {
		l = m.MapSize.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.PathingGrid != nil {
		l = m.PathingGrid.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.TerrainHeight != nil {
		l = m.TerrainHeight.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.PlacementGrid != nil {
		l = m.PlacementGrid.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.PlayableArea != nil {
		l = m.PlayableArea.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if len(m.StartLocations) > 0 {
		for _, e := range m.StartLocations {
			l = e.Size()
			n += 1 + l + sovRaw(uint64(l))
		}
	}
	return n
}

func (m *ObservationRaw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if len(m.Units) > 0 {
		for _, e := range m.Units {
			l = e.Size()
			n += 1 + l + sovRaw(uint64(l))
		}
	}
	if m.MapState != nil {
		l = m.MapState.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if len(m.Effects) > 0 {
		for _, e := range m.Effects {
			l = e.Size()
			n += 1 + l + sovRaw(uint64(l))
		}
	}
	if len(m.Radar) > 0 {
		for _, e := range m.Radar {
			l = e.Size()
			n += 1 + l + sovRaw(uint64(l))
		}
	}
	return n
}

func (m *RadarRing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.Radius != 0 {
		n += 5
	}
	return n
}

func (m *PowerSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.Radius != 0 {
		n += 5
	}
	if m.Tag != 0 {
		n += 1 + sovRaw(uint64(m.Tag))
	}
	return n
}

func (m *PlayerRaw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PowerSources) > 0 {
		for _, e := range m.PowerSources {
			l = e.Size()
			n += 1 + l + sovRaw(uint64(l))
		}
	}
	if m.Camera != nil {
		l = m.Camera.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if len(m.UpgradeIds) > 0 {
		l = 0
		for _, e := range m.UpgradeIds {
			l += sovRaw(uint64(e))
		}
		n += 1 + sovRaw(uint64(l)) + l
	}
	return n
}

func (m *UnitOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AbilityId != 0 {
		n += 1 + sovRaw(uint64(m.AbilityId))
	}
	if m.Target != nil {
		n += m.Target.Size()
	}
	if m.Progress != 0 {
		n += 5
	}
	return n
}

func (m *UnitOrder_TargetWorldSpacePos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetWorldSpacePos != nil {
		l = m.TargetWorldSpacePos.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	return n
}
func (m *UnitOrder_TargetUnitTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaw(uint64(m.TargetUnitTag))
	return n
}
func (m *PassengerUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovRaw(uint64(m.Tag))
	}
	if m.Health != 0 {
		n += 5
	}
	if m.HealthMax != 0 {
		n += 5
	}
	if m.Shield != 0 {
		n += 5
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.UnitType != 0 {
		n += 1 + sovRaw(uint64(m.UnitType))
	}
	if m.ShieldMax != 0 {
		n += 5
	}
	if m.EnergyMax != 0 {
		n += 5
	}
	return n
}

func (m *RallyTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.Tag != 0 {
		n += 1 + sovRaw(uint64(m.Tag))
	}
	return n
}

func (m *Unit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisplayType != 0 {
		n += 1 + sovRaw(uint64(m.DisplayType))
	}
	if m.Alliance != 0 {
		n += 1 + sovRaw(uint64(m.Alliance))
	}
	if m.Tag != 0 {
		n += 1 + sovRaw(uint64(m.Tag))
	}
	if m.UnitType != 0 {
		n += 1 + sovRaw(uint64(m.UnitType))
	}
	if m.Owner != 0 {
		n += 1 + sovRaw(uint64(m.Owner))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.Facing != 0 {
		n += 5
	}
	if m.Radius != 0 {
		n += 5
	}
	if m.BuildProgress != 0 {
		n += 5
	}
	if m.Cloak != 0 {
		n += 1 + sovRaw(uint64(m.Cloak))
	}
	if m.IsSelected {
		n += 2
	}
	if m.IsOnScreen {
		n += 2
	}
	if m.IsBlip {
		n += 2
	}
	if m.Health != 0 {
		n += 5
	}
	if m.HealthMax != 0 {
		n += 5
	}
	if m.Shield != 0 {
		n += 6
	}
	if m.Energy != 0 {
		n += 6
	}
	if m.MineralContents != 0 {
		n += 2 + sovRaw(uint64(m.MineralContents))
	}
	if m.VespeneContents != 0 {
		n += 2 + sovRaw(uint64(m.VespeneContents))
	}
	if m.IsFlying {
		n += 3
	}
	if m.IsBurrowed {
		n += 3
	}
	if len(m.Orders) > 0 {
		for _, e := range m.Orders {
			l = e.Size()
			n += 2 + l + sovRaw(uint64(l))
		}
	}
	if m.AddOnTag != 0 {
		n += 2 + sovRaw(uint64(m.AddOnTag))
	}
	if len(m.Passengers) > 0 {
		for _, e := range m.Passengers {
			l = e.Size()
			n += 2 + l + sovRaw(uint64(l))
		}
	}
	if m.CargoSpaceTaken != 0 {
		n += 2 + sovRaw(uint64(m.CargoSpaceTaken))
	}
	if m.CargoSpaceMax != 0 {
		n += 2 + sovRaw(uint64(m.CargoSpaceMax))
	}
	if len(m.BuffIds) > 0 {
		l = 0
		for _, e := range m.BuffIds {
			l += sovRaw(uint64(e))
		}
		n += 2 + sovRaw(uint64(l)) + l
	}
	if m.AssignedHarvesters != 0 {
		n += 2 + sovRaw(uint64(m.AssignedHarvesters))
	}
	if m.IdealHarvesters != 0 {
		n += 2 + sovRaw(uint64(m.IdealHarvesters))
	}
	if m.WeaponCooldown != 0 {
		n += 6
	}
	if m.DetectRange != 0 {
		n += 6
	}
	if m.RadarRange != 0 {
		n += 6
	}
	if m.EngagedTargetTag != 0 {
		n += 2 + sovRaw(uint64(m.EngagedTargetTag))
	}
	if m.IsPowered {
		n += 3
	}
	if m.ShieldMax != 0 {
		n += 6
	}
	if m.EnergyMax != 0 {
		n += 6
	}
	if m.IsHallucination {
		n += 3
	}
	if m.IsActive {
		n += 3
	}
	if m.AttackUpgradeLevel != 0 {
		n += 2 + sovRaw(uint64(m.AttackUpgradeLevel))
	}
	if m.ArmorUpgradeLevel != 0 {
		n += 2 + sovRaw(uint64(m.ArmorUpgradeLevel))
	}
	if m.ShieldUpgradeLevel != 0 {
		n += 2 + sovRaw(uint64(m.ShieldUpgradeLevel))
	}
	if m.BuffDurationRemain != 0 {
		n += 2 + sovRaw(uint64(m.BuffDurationRemain))
	}
	if m.BuffDurationMax != 0 {
		n += 2 + sovRaw(uint64(m.BuffDurationMax))
	}
	if len(m.RallyTargets) > 0 {
		for _, e := range m.RallyTargets {
			l = e.Size()
			n += 2 + l + sovRaw(uint64(l))
		}
	}
	return n
}

func (m *MapState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visibility != nil {
		l = m.Visibility.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.Creep != nil {
		l = m.Creep.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DeadUnits) > 0 {
		l = 0
		for _, e := range m.DeadUnits {
			l += sovRaw(uint64(e))
		}
		n += 1 + sovRaw(uint64(l)) + l
	}
	return n
}

func (m *Effect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EffectId != 0 {
		n += 1 + sovRaw(uint64(m.EffectId))
	}
	if len(m.Pos) > 0 {
		for _, e := range m.Pos {
			l = e.Size()
			n += 1 + l + sovRaw(uint64(l))
		}
	}
	if m.Alliance != 0 {
		n += 1 + sovRaw(uint64(m.Alliance))
	}
	if m.Owner != 0 {
		n += 1 + sovRaw(uint64(m.Owner))
	}
	if m.Radius != 0 {
		n += 5
	}
	return n
}

func (m *ActionRaw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *ActionRaw_UnitCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnitCommand != nil {
		l = m.UnitCommand.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	return n
}
func (m *ActionRaw_CameraMove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CameraMove != nil {
		l = m.CameraMove.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	return n
}
func (m *ActionRaw_ToggleAutocast) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToggleAutocast != nil {
		l = m.ToggleAutocast.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	return n
}
func (m *ActionRawUnitCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AbilityId != 0 {
		n += 1 + sovRaw(uint64(m.AbilityId))
	}
	if m.Target != nil {
		n += m.Target.Size()
	}
	if len(m.UnitTags) > 0 {
		l = 0
		for _, e := range m.UnitTags {
			l += sovRaw(uint64(e))
		}
		n += 1 + sovRaw(uint64(l)) + l
	}
	if m.QueueCommand {
		n += 2
	}
	return n
}

func (m *ActionRawUnitCommand_TargetWorldSpacePos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetWorldSpacePos != nil {
		l = m.TargetWorldSpacePos.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	return n
}
func (m *ActionRawUnitCommand_TargetUnitTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaw(uint64(m.TargetUnitTag))
	return n
}
func (m *ActionRawCameraMove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CenterWorldSpace != nil {
		l = m.CenterWorldSpace.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	return n
}

func (m *ActionRawToggleAutocast) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AbilityId != 0 {
		n += 1 + sovRaw(uint64(m.AbilityId))
	}
	if len(m.UnitTags) > 0 {
		l = 0
		for _, e := range m.UnitTags {
			l += sovRaw(uint64(e))
		}
		n += 1 + sovRaw(uint64(l)) + l
	}
	return n
}

func sovRaw(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRaw(x uint64) (n int) {
	return sovRaw(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StartRaw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartRaw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartRaw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSize == nil {
				m.MapSize = &Size2DI{}
			}
			if err := m.MapSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathingGrid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PathingGrid == nil {
				m.PathingGrid = &ImageData{}
			}
			if err := m.PathingGrid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerrainHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TerrainHeight == nil {
				m.TerrainHeight = &ImageData{}
			}
			if err := m.TerrainHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementGrid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlacementGrid == nil {
				m.PlacementGrid = &ImageData{}
			}
			if err := m.PlacementGrid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayableArea", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayableArea == nil {
				m.PlayableArea = &RectangleI{}
			}
			if err := m.PlayableArea.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartLocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartLocations = append(m.StartLocations, &Point2D{})
			if err := m.StartLocations[len(m.StartLocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObservationRaw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObservationRaw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObservationRaw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &PlayerRaw{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Units = append(m.Units, &Unit{})
			if err := m.Units[len(m.Units)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapState == nil {
				m.MapState = &MapState{}
			}
			if err := m.MapState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &Event{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Effects = append(m.Effects, &Effect{})
			if err := m.Effects[len(m.Effects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Radar = append(m.Radar, &RadarRing{})
			if err := m.Radar[len(m.Radar)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RadarRing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RadarRing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RadarRing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Point{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Radius = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PowerSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PowerSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PowerSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Point{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Radius = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= (UnitTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerRaw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerRaw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerRaw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerSources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PowerSources = append(m.PowerSources, &PowerSource{})
			if err := m.PowerSources[len(m.PowerSources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camera", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Camera == nil {
				m.Camera = &Point{}
			}
			if err := m.Camera.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v UpgradeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (UpgradeID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UpgradeIds = append(m.UpgradeIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRaw
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UpgradeIds) == 0 {
					m.UpgradeIds = make([]UpgradeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UpgradeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (UpgradeID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UpgradeIds = append(m.UpgradeIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnitOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnitOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnitOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityId", wireType)
			}
			m.AbilityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbilityId |= (AbilityID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetWorldSpacePos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Point{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &UnitOrder_TargetWorldSpacePos{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetUnitTag", wireType)
			}
			var v UnitTag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (UnitTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Target = &UnitOrder_TargetUnitTag{v}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Progress = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassengerUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassengerUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassengerUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= (UnitTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Health = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HealthMax = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shield", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Shield = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			m.UnitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitType |= (UnitTypeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShieldMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ShieldMax = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EnergyMax = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RallyTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RallyTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RallyTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Unit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Unit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Unit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayType", wireType)
			}
			m.DisplayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisplayType |= (DisplayType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alliance", wireType)
			}
			m.Alliance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alliance |= (Alliance(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= (UnitTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			m.UnitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitType |= (UnitTypeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= (PlayerID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Point{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Facing", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Facing = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Radius = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildProgress", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BuildProgress = float32(math.Float32frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloak", wireType)
			}
			m.Cloak = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cloak |= (CloakState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSelected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSelected = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOnScreen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOnScreen = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBlip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBlip = bool(v != 0)
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Health = float32(math.Float32frombits(v))
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HealthMax = float32(math.Float32frombits(v))
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shield", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Shield = float32(math.Float32frombits(v))
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MineralContents", wireType)
			}
			m.MineralContents = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MineralContents |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VespeneContents", wireType)
			}
			m.VespeneContents = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VespeneContents |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFlying", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFlying = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBurrowed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBurrowed = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orders = append(m.Orders, &UnitOrder{})
			if err := m.Orders[len(m.Orders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddOnTag", wireType)
			}
			m.AddOnTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddOnTag |= (UnitTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passengers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Passengers = append(m.Passengers, &PassengerUnit{})
			if err := m.Passengers[len(m.Passengers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CargoSpaceTaken", wireType)
			}
			m.CargoSpaceTaken = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CargoSpaceTaken |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CargoSpaceMax", wireType)
			}
			m.CargoSpaceMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CargoSpaceMax |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType == 0 {
				var v BuffID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (BuffID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BuffIds = append(m.BuffIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRaw
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BuffIds) == 0 {
					m.BuffIds = make([]BuffID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v BuffID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (BuffID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BuffIds = append(m.BuffIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffIds", wireType)
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedHarvesters", wireType)
			}
			m.AssignedHarvesters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignedHarvesters |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdealHarvesters", wireType)
			}
			m.IdealHarvesters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdealHarvesters |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponCooldown", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WeaponCooldown = float32(math.Float32frombits(v))
		case 31:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectRange", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DetectRange = float32(math.Float32frombits(v))
		case 32:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RadarRange", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RadarRange = float32(math.Float32frombits(v))
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EngagedTargetTag", wireType)
			}
			m.EngagedTargetTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EngagedTargetTag |= (UnitTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPowered", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPowered = bool(v != 0)
		case 36:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShieldMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ShieldMax = float32(math.Float32frombits(v))
		case 37:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EnergyMax = float32(math.Float32frombits(v))
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHallucination", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHallucination = bool(v != 0)
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackUpgradeLevel", wireType)
			}
			m.AttackUpgradeLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackUpgradeLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArmorUpgradeLevel", wireType)
			}
			m.ArmorUpgradeLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArmorUpgradeLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShieldUpgradeLevel", wireType)
			}
			m.ShieldUpgradeLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShieldUpgradeLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffDurationRemain", wireType)
			}
			m.BuffDurationRemain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffDurationRemain |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffDurationMax", wireType)
			}
			m.BuffDurationMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffDurationMax |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RallyTargets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RallyTargets = append(m.RallyTargets, &RallyTarget{})
			if err := m.RallyTargets[len(m.RallyTargets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Visibility == nil {
				m.Visibility = &ImageData{}
			}
			if err := m.Visibility.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creep == nil {
				m.Creep = &ImageData{}
			}
			if err := m.Creep.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v UnitTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (UnitTag(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DeadUnits = append(m.DeadUnits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRaw
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DeadUnits) == 0 {
					m.DeadUnits = make([]UnitTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UnitTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (UnitTag(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DeadUnits = append(m.DeadUnits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadUnits", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Effect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Effect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Effect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectId", wireType)
			}
			m.EffectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectId |= (EffectID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = append(m.Pos, &Point2D{})
			if err := m.Pos[len(m.Pos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alliance", wireType)
			}
			m.Alliance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alliance |= (Alliance(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Radius = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionRaw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionRaw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionRaw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitCommand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActionRawUnitCommand{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionRaw_UnitCommand{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CameraMove", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActionRawCameraMove{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionRaw_CameraMove{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToggleAutocast", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActionRawToggleAutocast{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionRaw_ToggleAutocast{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionRawUnitCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionRawUnitCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionRawUnitCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityId", wireType)
			}
			m.AbilityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbilityId |= (AbilityID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetWorldSpacePos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Point2D{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &ActionRawUnitCommand_TargetWorldSpacePos{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetUnitTag", wireType)
			}
			var v UnitTag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (UnitTag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Target = &ActionRawUnitCommand_TargetUnitTag{v}
		case 4:
			if wireType == 0 {
				var v UnitTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (UnitTag(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnitTags = append(m.UnitTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRaw
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnitTags) == 0 {
					m.UnitTags = make([]UnitTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UnitTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (UnitTag(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnitTags = append(m.UnitTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTags", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueCommand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueueCommand = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionRawCameraMove) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionRawCameraMove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionRawCameraMove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CenterWorldSpace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CenterWorldSpace == nil {
				m.CenterWorldSpace = &Point{}
			}
			if err := m.CenterWorldSpace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionRawToggleAutocast) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionRawToggleAutocast: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionRawToggleAutocast: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityId", wireType)
			}
			m.AbilityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbilityId |= (AbilityID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v UnitTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (UnitTag(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnitTags = append(m.UnitTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRaw
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnitTags) == 0 {
					m.UnitTags = make([]UnitTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UnitTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (UnitTag(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnitTags = append(m.UnitTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTags", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaw(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRaw
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRaw(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRaw = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaw   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("raw.proto", fileDescriptor_raw_2125900401486f3f) }

var fileDescriptor_raw_2125900401486f3f = []byte{
	// 2010 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x3b, 0x73, 0x1b, 0xc9,
	0x11, 0x26, 0x00, 0x02, 0x04, 0x1a, 0x4f, 0x0d, 0x29, 0x69, 0x45, 0x1d, 0x1f, 0x86, 0x4e, 0x27,
	0x89, 0xba, 0x93, 0x65, 0x9d, 0x1d, 0x5c, 0x95, 0x1f, 0xe2, 0xe3, 0xce, 0x44, 0x95, 0x1e, 0xf4,
	0x50, 0xb2, 0xab, 0x2e, 0xd9, 0x1a, 0xee, 0x36, 0x97, 0x53, 0x5a, 0xcc, 0xee, 0xcd, 0x2c, 0x48,
	0xf1, 0x22, 0x57, 0x39, 0x73, 0xe4, 0x3f, 0xe0, 0xcc, 0xa1, 0x63, 0xff, 0x00, 0x47, 0x0e, 0x2f,
	0x74, 0xa4, 0x72, 0x49, 0x8e, 0xfc, 0x13, 0x58, 0x0e, 0x5c, 0xf3, 0x58, 0x3c, 0xf9, 0x38, 0x97,
	0x9d, 0xa1, 0xbb, 0xbf, 0x9e, 0x47, 0x7f, 0x3d, 0xdd, 0xbd, 0x80, 0x9a, 0x64, 0x27, 0x8f, 0x52,
	0x99, 0x64, 0x09, 0x69, 0xed, 0x6f, 0x3f, 0xd9, 0xdc, 0xeb, 0xed, 0x69, 0x21, 0x48, 0xe2, 0x65,
	0x88, 0x92, 0x28, 0xb1, 0xb6, 0xe5, 0x46, 0x90, 0xf4, 0xfb, 0x89, 0xb0, 0x52, 0xf7, 0x77, 0x25,
	0xa8, 0xee, 0x67, 0x4c, 0x66, 0x94, 0x9d, 0x90, 0x27, 0x50, 0xed, 0xb3, 0xd4, 0x57, 0xfc, 0x5b,
	0xf4, 0x0a, 0xeb, 0x85, 0xfb, 0xf5, 0x27, 0x37, 0x1f, 0x4d, 0xae, 0xf4, 0x68, 0x9f, 0x7f, 0x8b,
	0x4f, 0x76, 0x7a, 0x74, 0xa1, 0xcf, 0x52, 0xfd, 0x9b, 0xfc, 0x14, 0x1a, 0x29, 0xcb, 0x8e, 0xb8,
	0x88, 0xfc, 0x48, 0xf2, 0xd0, 0x2b, 0x1a, 0xbf, 0x5b, 0xd3, 0x7e, 0xbd, 0x3e, 0x8b, 0x70, 0x87,
	0x65, 0x8c, 0xd6, 0x1d, 0xfc, 0x97, 0x92, 0x87, 0xe4, 0x29, 0xb4, 0x32, 0x94, 0x92, 0x71, 0xe1,
	0x1f, 0x21, 0x8f, 0x8e, 0x32, 0xaf, 0x74, 0x95, 0x7f, 0xd3, 0x39, 0xec, 0x1a, 0xbc, 0x5e, 0x21,
	0x8d, 0x59, 0x80, 0x7d, 0x14, 0x99, 0x3d, 0xc1, 0xfc, 0x95, 0x2b, 0x0c, 0x1d, 0xcc, 0x19, 0x7e,
	0x01, 0x5a, 0x71, 0xca, 0x0e, 0x62, 0xf4, 0x99, 0x44, 0xe6, 0x95, 0xcd, 0x02, 0xcb, 0xd3, 0x0b,
	0x50, 0x0c, 0x32, 0x26, 0xa2, 0x18, 0x7b, 0xb4, 0x91, 0x3b, 0x6c, 0x4a, 0x64, 0xe4, 0x29, 0xb4,
	0x95, 0x0e, 0xa1, 0x1f, 0x27, 0x01, 0xcb, 0x78, 0x22, 0x94, 0x57, 0x59, 0x2f, 0x9d, 0x17, 0xbd,
	0xbd, 0x84, 0x8b, 0xec, 0xc9, 0x0e, 0x6d, 0x19, 0xfc, 0xb3, 0x1c, 0xde, 0xfd, 0x4b, 0x11, 0x5a,
	0x2f, 0x0f, 0x14, 0xca, 0x63, 0xa3, 0xd0, 0x5c, 0xfc, 0x08, 0x2a, 0x7a, 0x13, 0x94, 0x8e, 0x89,
	0x99, 0xfb, 0xec, 0x19, 0x2b, 0x65, 0x27, 0xd4, 0x01, 0xc9, 0x06, 0x94, 0x07, 0x82, 0x67, 0xca,
	0x2b, 0x9a, 0xdd, 0x97, 0xa6, 0x3d, 0x5e, 0x0b, 0x9e, 0x51, 0x0b, 0x21, 0x3f, 0x81, 0x9a, 0xa1,
	0x3a, 0x63, 0x19, 0xba, 0x98, 0x7b, 0xd3, 0xf8, 0xe7, 0x2c, 0xdd, 0xd7, 0x76, 0xaa, 0xb3, 0xc2,
	0xfc, 0x22, 0x0f, 0xa1, 0x8c, 0xc7, 0x28, 0x32, 0x17, 0xe4, 0xeb, 0xd3, 0x2e, 0x5f, 0x6a, 0x23,
	0xb5, 0x18, 0xf2, 0x18, 0x16, 0xf0, 0xf0, 0x10, 0x83, 0x4c, 0x79, 0x65, 0x73, 0xa2, 0x1b, 0x33,
	0x70, 0x63, 0xa6, 0x39, 0x8c, 0xfc, 0x10, 0xca, 0x92, 0x85, 0x4c, 0xba, 0xf8, 0xcd, 0xdc, 0x99,
	0x6a, 0x23, 0xe5, 0x22, 0xa2, 0x16, 0xd7, 0x7d, 0x06, 0xb5, 0xa1, 0x8e, 0xdc, 0x83, 0x52, 0x9a,
	0x28, 0x17, 0xaf, 0xeb, 0xe7, 0xc6, 0x9e, 0x6a, 0x04, 0xb9, 0x01, 0x15, 0xc9, 0x42, 0x3e, 0x50,
	0x26, 0x5b, 0x8b, 0xd4, 0x49, 0xdd, 0x3e, 0xd4, 0xf7, 0x92, 0x13, 0x94, 0xfb, 0xc9, 0x40, 0x06,
	0xf8, 0x3f, 0xaf, 0x47, 0x56, 0xa0, 0x94, 0xb1, 0xc8, 0x84, 0x77, 0x7e, 0xab, 0x7e, 0xf6, 0x6e,
	0x6d, 0x41, 0x53, 0xf0, 0x8a, 0x45, 0x54, 0xeb, 0xbb, 0x7f, 0x2e, 0x40, 0x6d, 0xc8, 0x22, 0x79,
	0x0a, 0xcd, 0x54, 0x6f, 0xee, 0x2b, 0xb3, 0xbb, 0xde, 0x57, 0xc7, 0xe0, 0xf6, 0xec, 0xbe, 0xc3,
	0x13, 0xd2, 0x46, 0x3a, 0x12, 0x14, 0xf9, 0x0c, 0x2a, 0x01, 0xeb, 0xa3, 0x64, 0xee, 0x11, 0x5e,
	0x70, 0x64, 0x07, 0x22, 0x8f, 0xa0, 0x3e, 0x48, 0x23, 0xc9, 0x42, 0xf4, 0x79, 0xa8, 0xbc, 0xd2,
	0x7a, 0xe9, 0x7e, 0x73, 0xab, 0x79, 0xf6, 0x6e, 0xad, 0xf6, 0xda, 0xaa, 0x7b, 0x3b, 0x14, 0x1c,
	0xa2, 0x17, 0xaa, 0xee, 0x3f, 0x0b, 0x50, 0xd3, 0xe7, 0x7f, 0x29, 0x43, 0x94, 0xe4, 0x53, 0x00,
	0x76, 0xc0, 0x63, 0x9e, 0x9d, 0xfa, 0x3c, 0x34, 0x31, 0x72, 0xce, 0x9b, 0x56, 0xdb, 0xdb, 0xa1,
	0x35, 0x07, 0xe8, 0x85, 0xe4, 0x19, 0xdc, 0xc8, 0x98, 0x8c, 0x30, 0xf3, 0x4f, 0x12, 0x19, 0x87,
	0xbe, 0x4a, 0x59, 0x80, 0xbe, 0x8e, 0xee, 0x65, 0x47, 0xdd, 0x9d, 0xa3, 0x8b, 0xd6, 0xed, 0x37,
	0xda, 0x6b, 0x5f, 0x3b, 0xed, 0x25, 0x3a, 0x79, 0xdb, 0x6e, 0x35, 0x9d, 0xcc, 0xfe, 0xf9, 0x31,
	0xde, 0x9d, 0xa3, 0x4d, 0x8b, 0x72, 0x0a, 0xb2, 0x0c, 0xd5, 0x54, 0x26, 0x91, 0x44, 0xa5, 0x4c,
	0xfe, 0x16, 0xe9, 0x50, 0xde, 0xaa, 0x42, 0xc5, 0x82, 0xbb, 0xbf, 0x2d, 0x42, 0x73, 0x8f, 0x29,
	0x85, 0x22, 0x42, 0xa9, 0x5d, 0x73, 0x1a, 0x0b, 0xe7, 0xd3, 0xa8, 0xd9, 0x3f, 0x42, 0x16, 0x67,
	0x47, 0x39, 0xfb, 0x56, 0x22, 0x2b, 0x00, 0xf6, 0x97, 0xdf, 0x67, 0x6f, 0xcd, 0x01, 0x8b, 0xb4,
	0x66, 0x35, 0xcf, 0xd9, 0x5b, 0xed, 0xa6, 0x8e, 0x38, 0xc6, 0xa1, 0x3b, 0x8b, 0x93, 0xb4, 0x1e,
	0x05, 0xca, 0xe8, 0xd4, 0xd4, 0xa1, 0x22, 0x75, 0x12, 0x79, 0x08, 0x35, 0x7b, 0xdb, 0xd3, 0x14,
	0xbd, 0x8a, 0x89, 0x77, 0xeb, 0xec, 0xdd, 0x1a, 0x98, 0xb3, 0x9c, 0xa6, 0x9a, 0xad, 0xea, 0xc0,
	0xfd, 0xd6, 0x7b, 0xdb, 0xe5, 0xcc, 0xde, 0x0b, 0x76, 0x6f, 0xab, 0xd1, 0x7b, 0xaf, 0x00, 0xd8,
	0x55, 0x8d, 0xb9, 0x6a, 0xcd, 0x56, 0xf3, 0x9c, 0xbd, 0xed, 0x3e, 0x83, 0x3a, 0x65, 0x71, 0x7c,
	0xfa, 0xca, 0x44, 0x44, 0x3f, 0xfa, 0x54, 0xd3, 0x71, 0xf9, 0x4b, 0xb0, 0x18, 0xd2, 0xb1, 0xc1,
	0xd2, 0xa1, 0x98, 0xb7, 0x69, 0xfe, 0xaf, 0x26, 0xcc, 0x9b, 0x38, 0xfe, 0x1c, 0x1a, 0x21, 0x57,
	0xba, 0x58, 0xd9, 0x4b, 0xe8, 0xe5, 0x5a, 0xb3, 0x09, 0xbe, 0x63, 0x31, 0xfa, 0x1e, 0xb4, 0x1e,
	0x8e, 0x04, 0xf2, 0x63, 0xa8, 0xb2, 0x38, 0xe6, 0x4c, 0x04, 0x68, 0xd6, 0x6f, 0xcd, 0x96, 0xac,
	0x4d, 0x67, 0xa7, 0x43, 0xe4, 0x15, 0x8f, 0x70, 0x32, 0xac, 0xf3, 0x57, 0x84, 0xb5, 0x0b, 0xe5,
	0xe4, 0x44, 0xa0, 0x34, 0xd4, 0x94, 0xb7, 0x1a, 0x67, 0xef, 0xd6, 0xaa, 0xf6, 0x05, 0xf7, 0x76,
	0xa8, 0x35, 0xe5, 0x55, 0xa3, 0xf2, 0x7d, 0xaa, 0xc6, 0x21, 0x0b, 0xb8, 0x88, 0x1c, 0x3f, 0x4e,
	0x1a, 0xab, 0x26, 0xd5, 0x89, 0x6a, 0x72, 0x17, 0x5a, 0x07, 0x03, 0x1e, 0x87, 0xfe, 0x30, 0x89,
	0x6b, 0xc6, 0xde, 0x34, 0xda, 0x3d, 0xa7, 0x24, 0x8f, 0xa1, 0x1c, 0xc4, 0x09, 0x7b, 0xe3, 0x81,
	0x09, 0xd1, 0x4c, 0x1b, 0xdb, 0xd6, 0x46, 0x5b, 0xd7, 0x2d, 0x90, 0xac, 0x41, 0x9d, 0x2b, 0x5f,
	0x61, 0x8c, 0x41, 0x86, 0xa1, 0x57, 0x5f, 0x2f, 0xdc, 0xaf, 0x52, 0xe0, 0x6a, 0xdf, 0x69, 0xc8,
	0x3a, 0x34, 0xb8, 0xf2, 0x13, 0xe1, 0xab, 0x40, 0x22, 0x0a, 0xaf, 0x91, 0x23, 0x5e, 0x8a, 0x7d,
	0xa3, 0x21, 0x37, 0x61, 0x81, 0x2b, 0xff, 0x20, 0xe6, 0xa9, 0xd7, 0x34, 0xc6, 0x0a, 0x57, 0x5b,
	0x31, 0x4f, 0xc7, 0x1e, 0x47, 0xeb, 0x92, 0xc7, 0xd1, 0xbe, 0xf8, 0x71, 0x74, 0x2e, 0x78, 0x1c,
	0xd7, 0x26, 0x1e, 0xc7, 0x03, 0xe8, 0xf4, 0xb9, 0x40, 0xc9, 0x62, 0x3f, 0x48, 0x44, 0x86, 0x22,
	0x53, 0x1e, 0xd1, 0x1c, 0xd1, 0xb6, 0xd3, 0x6f, 0x3b, 0xb5, 0x86, 0x1e, 0xa3, 0x4a, 0x51, 0xe0,
	0x08, 0xba, 0x68, 0xa1, 0x4e, 0x3f, 0x84, 0xde, 0x86, 0x1a, 0x57, 0xfe, 0x61, 0x7c, 0xaa, 0x49,
	0x5a, 0x32, 0xf7, 0xaa, 0x72, 0xf5, 0x95, 0x91, 0x5d, 0xd4, 0x0e, 0x06, 0x52, 0x26, 0x27, 0x18,
	0x7a, 0xd7, 0xf3, 0x98, 0x6c, 0x39, 0x8d, 0xee, 0xe0, 0x89, 0x2e, 0x95, 0xca, 0xbb, 0x71, 0x7e,
	0x37, 0x1b, 0x16, 0x53, 0xea, 0x80, 0xe4, 0x01, 0x00, 0x0b, 0x43, 0x1d, 0x69, 0x9d, 0xb2, 0x37,
	0x67, 0x53, 0xb6, 0xca, 0xc2, 0xf0, 0xa5, 0xd0, 0xc5, 0xec, 0x67, 0x00, 0x69, 0x5e, 0xa5, 0x94,
	0xe7, 0x99, 0x1d, 0x56, 0x66, 0xb2, 0x6d, 0xbc, 0x8e, 0xd1, 0x31, 0x07, 0xb2, 0x01, 0xd7, 0x02,
	0x26, 0xa3, 0xc4, 0x55, 0xe2, 0x8c, 0xbd, 0x41, 0xe1, 0xdd, 0xb2, 0x61, 0x30, 0x06, 0x53, 0x6c,
	0x5f, 0x69, 0x35, 0xf9, 0x04, 0xda, 0xe3, 0x58, 0x4d, 0xd8, 0xb2, 0x41, 0x36, 0x47, 0x48, 0x4d,
	0xda, 0x5d, 0xa8, 0x1e, 0x0c, 0x0e, 0x0f, 0x4d, 0x37, 0xb9, 0x6d, 0xba, 0x09, 0x9c, 0xbd, 0x5b,
	0xab, 0x6c, 0x0d, 0x0e, 0x0f, 0x7b, 0x3b, 0x74, 0x41, 0xdb, 0x7a, 0xa1, 0x6e, 0xf2, 0x8b, 0x4c,
	0x29, 0x1e, 0x09, 0x0c, 0xfd, 0x23, 0x26, 0x8f, 0x51, 0x65, 0xfa, 0x0a, 0x1f, 0x99, 0x25, 0x49,
	0x6e, 0xda, 0x1d, 0x5a, 0x34, 0x63, 0x3c, 0x44, 0x16, 0x8f, 0xa3, 0x57, 0xec, 0x51, 0x8d, 0x7e,
	0x0c, 0x7a, 0x0f, 0xda, 0x27, 0xc8, 0xd2, 0x44, 0xf8, 0x41, 0x92, 0xc4, 0x61, 0x72, 0x22, 0xbc,
	0x55, 0x93, 0x28, 0x2d, 0xab, 0xde, 0x76, 0x5a, 0xf2, 0x03, 0x68, 0x84, 0x98, 0x61, 0x90, 0xf9,
	0x92, 0x89, 0x08, 0xbd, 0x35, 0x83, 0xaa, 0x5b, 0x1d, 0xd5, 0x2a, 0x4d, 0xb0, 0x19, 0x32, 0x1c,
	0x62, 0xdd, 0x20, 0xc0, 0xa8, 0x2c, 0xe0, 0x0b, 0x20, 0x28, 0x22, 0x16, 0x61, 0xe8, 0xbb, 0x76,
	0xa4, 0x59, 0xeb, 0xce, 0xb2, 0xd6, 0x71, 0x30, 0x5b, 0x4f, 0x35, 0x7b, 0x2b, 0x00, 0x5c, 0xf9,
	0xa6, 0x7b, 0x63, 0xe8, 0xdd, 0x31, 0xb9, 0x53, 0xe3, 0x6a, 0xcf, 0x2a, 0xa6, 0xca, 0xf7, 0xc7,
	0x97, 0x97, 0xef, 0xbb, 0x53, 0xe5, 0xdb, 0xc4, 0x4b, 0xf9, 0x47, 0x2c, 0x8e, 0x07, 0x01, 0x17,
	0x66, 0xa2, 0xf4, 0x3e, 0x31, 0x5b, 0xb4, 0xb9, 0xda, 0x1d, 0x57, 0xbb, 0x0c, 0x67, 0x41, 0xc6,
	0x8f, 0xd1, 0xbb, 0x97, 0x67, 0xf8, 0xa6, 0x91, 0xc9, 0x63, 0x58, 0x62, 0x59, 0xc6, 0x82, 0x37,
	0x7e, 0x3e, 0x27, 0xc4, 0x78, 0x8c, 0xb1, 0x77, 0xdf, 0x31, 0x65, 0x6c, 0x6e, 0x56, 0x78, 0xa6,
	0x2d, 0xe4, 0x11, 0x2c, 0x32, 0xd9, 0x4f, 0xe4, 0x94, 0xc3, 0x03, 0xe3, 0x70, 0xcd, 0x98, 0x26,
	0xf0, 0x8f, 0x61, 0xc9, 0xdd, 0x73, 0xd2, 0x61, 0xc3, 0xee, 0x60, 0x6d, 0xd3, 0x1e, 0x26, 0xc7,
	0xc2, 0x81, 0x34, 0x37, 0xf0, 0x25, 0xf6, 0x19, 0x17, 0xde, 0x43, 0xeb, 0xa1, 0x6d, 0x3b, 0xce,
	0x44, 0x8d, 0x45, 0x67, 0xfa, 0xa4, 0x87, 0x8e, 0xd9, 0xa7, 0x36, 0x7d, 0xc6, 0xe1, 0x3a, 0x72,
	0x4f, 0xa1, 0x29, 0x75, 0xe3, 0x73, 0x7c, 0x2a, 0xef, 0xb3, 0xf3, 0x67, 0xb0, 0xb1, 0xee, 0x48,
	0x1b, 0x72, 0x24, 0xa8, 0xee, 0x31, 0x54, 0xf3, 0xb1, 0x99, 0x7c, 0x01, 0x70, 0xcc, 0x15, 0xb7,
	0x43, 0xd0, 0x45, 0x63, 0xfc, 0xe8, 0xb3, 0x64, 0x0c, 0xac, 0x07, 0x61, 0x5d, 0x58, 0xd3, 0xab,
	0x3f, 0xa7, 0x2c, 0xae, 0xfb, 0x39, 0x94, 0xcd, 0xec, 0x4d, 0x36, 0x00, 0x42, 0x64, 0xa1, 0x6f,
	0xbf, 0x04, 0xf4, 0x0c, 0x39, 0x95, 0x8c, 0x35, 0x6d, 0xd6, 0x82, 0xea, 0xfe, 0xb5, 0x00, 0x15,
	0x3b, 0x82, 0x93, 0x07, 0x50, 0xb3, 0x43, 0xf8, 0x68, 0x9a, 0x33, 0xdd, 0xcd, 0x9a, 0x75, 0x13,
	0xb4, 0xe6, 0x5e, 0x48, 0x1e, 0xd8, 0x06, 0x57, 0xbc, 0xfc, 0x13, 0xc7, 0xb4, 0xb8, 0xf1, 0x8e,
	0x5d, 0xfa, 0xde, 0x1d, 0x7b, 0x29, 0xef, 0xb2, 0xf3, 0x86, 0x25, 0xd7, 0x57, 0x47, 0x6d, 0xb1,
	0x3c, 0x31, 0xb4, 0xff, 0xbb, 0x00, 0x35, 0x9d, 0xb0, 0xf6, 0xb3, 0xa9, 0x07, 0x0d, 0xd3, 0xce,
	0xf5, 0x47, 0x2e, 0x13, 0xa1, 0x8b, 0xfa, 0xc7, 0x33, 0xbb, 0xe6, 0x0e, 0x3a, 0x10, 0xdb, 0x16,
	0xbb, 0x3b, 0x47, 0xeb, 0x83, 0x91, 0x48, 0xbe, 0x82, 0xba, 0x9d, 0x94, 0xfd, 0x7e, 0x72, 0x8c,
	0x8e, 0x89, 0x3b, 0x17, 0xae, 0xb4, 0x6d, 0xb0, 0xcf, 0x93, 0x63, 0xdc, 0x9d, 0xa3, 0x10, 0x0c,
	0x25, 0x42, 0xa1, 0x9d, 0x25, 0x51, 0xa4, 0xbf, 0x2e, 0x07, 0x59, 0x12, 0x30, 0x95, 0x7f, 0xe4,
	0xde, 0xbb, 0x70, 0xad, 0x57, 0x06, 0xbf, 0xe9, 0xe0, 0xbb, 0x73, 0xb4, 0x95, 0x4d, 0x68, 0xf4,
	0xb8, 0xca, 0x0c, 0xb8, 0xfb, 0xa7, 0x22, 0x2c, 0x9d, 0x77, 0x9b, 0x73, 0x06, 0xf4, 0xf2, 0x25,
	0x03, 0xfa, 0x8b, 0x2b, 0x06, 0xf4, 0x8b, 0x78, 0xfe, 0x3f, 0x8f, 0xe8, 0xf7, 0xf3, 0x69, 0x8c,
	0x45, 0x7a, 0x46, 0x9f, 0x49, 0x5e, 0x3b, 0x8a, 0xb1, 0x48, 0x91, 0x3b, 0xd0, 0xfc, 0x66, 0x80,
	0x03, 0x1c, 0x32, 0x5d, 0x36, 0xd5, 0xab, 0x61, 0x94, 0x2e, 0x06, 0x63, 0x53, 0xfd, 0xd7, 0xb0,
	0x78, 0x0e, 0x53, 0x64, 0x1b, 0x48, 0x80, 0x22, 0x43, 0x39, 0x7e, 0xed, 0xcb, 0xe7, 0xdc, 0x8e,
	0x75, 0x18, 0x5d, 0xb7, 0xfb, 0x0d, 0xdc, 0xbc, 0x80, 0xb9, 0xff, 0x92, 0x84, 0x89, 0xdb, 0x17,
	0x2f, 0xb9, 0xfd, 0x46, 0x00, 0xf5, 0xb1, 0x31, 0x99, 0x7c, 0x04, 0xed, 0x31, 0xd1, 0x17, 0x3c,
	0xee, 0xcc, 0x2d, 0x2f, 0xfc, 0xfe, 0x8f, 0xeb, 0x25, 0xc1, 0x63, 0x52, 0x87, 0x85, 0x5f, 0xeb,
	0xd2, 0x12, 0x63, 0xa7, 0x40, 0x1a, 0x50, 0xdd, 0x17, 0x2c, 0x55, 0x47, 0x49, 0xd6, 0x29, 0x12,
	0x80, 0xca, 0x2e, 0x0f, 0x43, 0x14, 0x9d, 0x12, 0x69, 0x43, 0x7d, 0x2f, 0x66, 0x01, 0x1e, 0x25,
	0x71, 0x88, 0xb2, 0x33, 0xbf, 0xf1, 0x2b, 0xa8, 0xe6, 0xaf, 0x93, 0xdc, 0x82, 0x46, 0xfe, 0x7b,
	0x7a, 0xf9, 0x2a, 0xcc, 0xef, 0x63, 0x7c, 0xd8, 0x29, 0xe8, 0x5f, 0x9b, 0x71, 0x7c, 0xda, 0x29,
	0xea, 0x2d, 0x5f, 0xe0, 0x20, 0x93, 0x2c, 0xee, 0x94, 0x48, 0x0d, 0xca, 0x5f, 0x0a, 0xec, 0x9f,
	0x76, 0xe6, 0x37, 0x10, 0x60, 0x34, 0x7f, 0x12, 0x02, 0x2d, 0x23, 0x61, 0xf8, 0x5a, 0xbc, 0x11,
	0xc9, 0x89, 0xe8, 0xcc, 0x69, 0x4f, 0xa7, 0xeb, 0x14, 0xc8, 0x22, 0xb4, 0x9d, 0xb0, 0x63, 0x1a,
	0x33, 0x86, 0x9d, 0x22, 0x69, 0x01, 0xbc, 0x48, 0xb2, 0x1c, 0x54, 0x22, 0xd7, 0xa0, 0xe9, 0x04,
	0x7d, 0x42, 0x0c, 0x3b, 0xf3, 0x5b, 0x2b, 0x7f, 0x7b, 0xbf, 0x5a, 0xf8, 0xee, 0xfd, 0x6a, 0xe1,
	0x1f, 0xef, 0x57, 0x0b, 0x7f, 0xf8, 0xb0, 0x3a, 0xf7, 0xdd, 0x87, 0xd5, 0xb9, 0xbf, 0x7f, 0x58,
	0x9d, 0xfb, 0xba, 0xc4, 0x52, 0x7e, 0x50, 0x31, 0xff, 0x7d, 0x7d, 0xfe, 0x9f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xf4, 0x77, 0x17, 0x06, 0x32, 0x13, 0x00, 0x00,
}
