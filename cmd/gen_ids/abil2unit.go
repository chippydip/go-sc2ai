package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"

	"github.com/chippydip/go-sc2ai/api"
)

func mapAbilityToProducedUnit(names []string, units []*api.UnitTypeData) {
	mapping := map[string]string{}
	failed := false
	for _, name := range names {
		stripped := stripProductionPrefix(name)
		unit := getProducedUnit(stripped, units)
		if unit != "" {
			mapping[name] = unit
		} else if stripped != "" {
			fmt.Printf("No Match: %v\n", name)
			failed = true
		}
	}

	if failed {
		panic("ability map failures")
	}

	writeMapping(mapping)
}

// Types of abilities to map
var productionPrefixes = []string{
	"Build_",
	"Morph_",
	"TrainWarp_",
	"Train_",
}

// Names that don't match the units they produce (empty means ignore)
var nameOverrides = map[string]string{
	"CreepTumor_Queen":       "CreepTumor",
	"CreepTumor_Tumor":       "CreepTumor",
	"Interceptors":           "Interceptor",
	"LurkerDen":              "LurkerDenMP",
	"NydusWorm":              "NydusCanal",
	"Reactor_Barracks":       "BarracksReactor",
	"Reactor_Factory":        "FactoryReactor",
	"Reactor_Starport":       "StarportReactor",
	"StasisTrap":             "",
	"TechLab_Barracks":       "BarracksTechLab",
	"TechLab_Factory":        "FactoryTechLab",
	"TechLab_Starport":       "StarportTechLab",
	"BurrowDown_1398":        "",
	"BurrowDown_1400":        "",
	"BurrowDown_2489":        "",
	"BurrowUp_1402":          "",
	"BurrowUp_1404":          "",
	"BurrowUp_2491":          "",
	"Cancel_1519":            "",
	"Cancel_2480":            "",
	"Cancel_2482":            "",
	"Hellbat":                "HellionTank",
	"LiberatorAAMode":        "",
	"LiberatorAGMode":        "",
	"Lurker":                 "LurkerMP",
	"ObserverMode":           "",
	"OverseerMode":           "",
	"OversightMode":          "",
	"Root":                   "",
	"SiegeMode":              "",
	"SpineCrawlerRoot":       "",
	"SpineCrawlerUproot":     "",
	"SporeCrawlerRoot":       "",
	"SporeCrawlerUproot":     "",
	"SupplyDepot_Lower":      "",
	"SupplyDepot_Raise":      "",
	"SurveillanceMode":       "",
	"ThorExplosiveMode":      "",
	"ThorHighImpactMode":     "",
	"Unsiege":                "",
	"Uproot":                 "",
	"VikingAssaultMode":      "",
	"VikingFighterMode":      "",
	"WarpPrismPhasingMode":   "",
	"WarpPrismTransportMode": "",
	"SwarmHost":              "SwarmHostMP",
}

func stripProductionPrefix(name string) string {
	for _, prefix := range productionPrefixes {
		if strings.HasPrefix(name, prefix) {
			name = name[len(prefix):]
			if override, ok := nameOverrides[name]; ok {
				return override
			}
			return name
		}
	}
	return ""
}

func getProducedUnit(ability string, units []*api.UnitTypeData) string {
	if ability == "" {
		return ""
	}

	for _, unit := range units {
		unitName := makeID(unit.Name)
		if !unit.GetAvailable() || unitName != ability {
			continue
		}

		race := unit.Race.String()
		if race == "NoRace" {
			race = "Neutral"
		}

		return fmt.Sprintf("%v_%v", race, unitName)
	}
	return ""
}

const header = `// Code generated by gen_ids. DO NOT EDIT.
package ability

import (
	"github.com/chippydip/go-sc2ai/api"
	"github.com/chippydip/go-sc2ai/enums/unit"
)

// Produces returns the UnitTypeID produced by the given AbilityID.
// If the ability doesn't produce a unit, it returns Invalid.
func Produces(ability api.AbilityID) api.UnitTypeID {
	return produces[ability]
}

var produces = map[api.AbilityID]api.UnitTypeID{
`

func writeMapping(values map[string]string) {
	fmtString := "\t%-*v unit.%v,\n"

	maxLen := 0
	for key := range values {
		if len(key) > maxLen {
			maxLen = len(key)
		}
	}

	file, err := os.Create("enums/ability/production.go")
	check(err)
	defer file.Close()

	w := bufio.NewWriter(file)

	fmt.Fprint(w, header)

	for key, value := range values {
		fmt.Fprintf(w, fmtString, maxLen+1, key+":", value)
	}
	fmt.Fprint(w, "}\n")
	check(w.Flush())
}
